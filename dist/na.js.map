{"version":3,"file":"na.js","names":["compass: string","degrees: number","localeChangeCallbacks: (() => void)[]","customParseFormat","utc","setDateLocale"],"sources":["../src/na/constants.ts","../src/na/compass.ts","../src/na/coordinates.ts","../src/na/server-time.ts","../src/locale.ts","../src/unicode.ts","../src/date/date.ts","../src/na/time.ts","../src/na/wind.ts"],"sourcesContent":["export const speedFactor = 390\nexport const timeFactor = 2.63\n\nexport const distanceMapSize = 8192\nexport const mapSize = 8192\nexport const minDeepWaterBR = 22\n\nexport const serverMaintenanceHour = 10\nexport const hoursPerDay = 24\nexport const maxPortBattleHour = serverMaintenanceHour - 2\n\nexport const degreesFullCircle = 360\nexport const degreesHalfCircle = 180\nexport const degreesQuarterCircle = 90\n","import { degreesFullCircle, degreesHalfCircle } from \"./constants.js\"\n\n/**\n * Compass directions using 24-point compass rose.\n * Each direction represents 15° (360° / 24).\n *\n * Format uses fractional notation:\n * - N⅓NE means \"North by one-third toward Northeast\" (between N and NE)\n * - N⅔NE means \"North by two-thirds toward Northeast\" (closer to NE)\n */\nexport const compassDirections = [\n    \"N\",\n    \"N⅓NE\",\n    \"N⅔NE\",\n    \"NE\",\n    \"E⅔NE\",\n    \"E⅓NE\",\n    \"E\",\n    \"E⅓SE\",\n    \"E⅔SE\",\n    \"SE\",\n    \"S⅔SE\",\n    \"S⅓SE\",\n    \"S\",\n    \"S⅓SW\",\n    \"S⅔SW\",\n    \"SW\",\n    \"W⅔SW\",\n    \"W⅓SW\",\n    \"W\",\n    \"W⅓NW\",\n    \"W⅔NW\",\n    \"NW\",\n    \"N⅔NW\",\n    \"N⅓NW\",\n] as const\n\n/**\n * Degrees per compass direction (15° for 24-point compass).\n */\nexport const degreesPerDirection = degreesFullCircle / compassDirections.length\n\n// ============================================================================\n// Conversion Functions\n// ============================================================================\n\n/**\n * Converts a compass direction to degrees.\n *\n * @param compass - Compass direction (e.g., \"N\", \"NE\", \"E⅓SE\").\n * @returns Degrees (0-345 in 15° increments).\n *\n * @example\n * compassToDegrees(\"N\")    // 0\n * compassToDegrees(\"NE\")   // 45\n * compassToDegrees(\"E\")    // 90\n * compassToDegrees(\"S\")    // 180\n */\nexport const compassToDegrees = (compass: string): number => {\n    const index = compassDirections.indexOf(compass as (typeof compassDirections)[number])\n    return index * degreesPerDirection\n}\n\n/**\n * Converts degrees to the nearest compass direction.\n *\n * @param degrees - Angle in degrees (0-360).\n * @returns Compass direction, or \"n/a\" if degrees is undefined.\n *\n * @example\n * degreesToCompass(0)    // \"N\"\n * degreesToCompass(45)   // \"NE\"\n * degreesToCompass(135)  // \"SE\"\n * degreesToCompass(355)  // \"N\" (wraps around)\n */\nexport const degreesToCompass = (degrees: number | undefined): string => {\n    if (degrees === undefined) {\n        return \"n/a\"\n    }\n\n    // Round to nearest direction (add 0.5 tick for rounding)\n    const index = Math.floor(degrees / degreesPerDirection + 0.5)\n\n    // Handle wrap-around using modulo\n    return compassDirections[index % compassDirections.length] ?? \"\"\n}\n\n/**\n * Converts a slider value (adjusted by 180°) to compass direction.\n * Used when sliders have their zero point shifted.\n *\n * @param degrees - Slider value in degrees.\n * @returns Compass direction.\n *\n * @example\n * degreesToCompassSlider(180) // \"N\" (180° + 180° = 360° = 0°)\n */\nexport const degreesToCompassSlider = (degrees: number | undefined): string =>\n    degreesToCompass(compassDirectionFromSlider(degrees))\n\n/**\n * Adjusts compass direction from slider by adding 180°.\n * This shifts the slider's reference point by half a circle.\n *\n * @param compassDirection - Direction value from slider.\n * @returns Adjusted direction in degrees.\n *\n * @example\n * compassDirectionFromSlider(0)   // 180\n * compassDirectionFromSlider(180) // 0 (wraps around)\n */\nexport const compassDirectionFromSlider = (compassDirection: number | undefined): number =>\n    (Number(compassDirection) + degreesHalfCircle) % degreesFullCircle\n\n/**\n * Formats a wind direction as both compass direction and degrees.\n *\n * @param wind - Wind direction as compass string or degrees number.\n * @param svg - If true, uses 'tspan' tags instead of 'span' (for SVG context).\n * @returns HTML string with formatted compass and degrees.\n *\n * @example\n * displayCompassAndDegrees(45)     // \"<span class=\"caps\">NE</span> (45°)\"\n * displayCompassAndDegrees(\"NE\")   // \"<span class=\"caps\">NE</span> (45°)\"\n * displayCompassAndDegrees(90, true) // \"<tspan class=\"caps\">E</tspan> (90°)\"\n */\nexport const displayCompassAndDegrees = (wind: number | string, svg = false): string => {\n    let compass: string\n    let degrees: number\n\n    // Determine if input is compass string or degrees\n    if (Number.isNaN(Number(wind))) {\n        compass = wind as string\n        degrees = compassToDegrees(compass) % degreesFullCircle\n    } else {\n        degrees = Number(wind)\n        compass = degreesToCompass(degrees)\n    }\n\n    const tag = svg ? \"tspan\" : \"span\"\n    return `<${tag} class=\"caps\">${compass}</${tag}> (${degrees}°)`\n}\n\n// ============================================================================\n// Direction Type Checking\n// ============================================================================\n\n/**\n * Checks if a compass index represents a cardinal or intercardinal direction.\n * Cardinal: N, E, S, W (every 6th position)\n * Intercardinal: NE, SE, SW, NW (every 6th position, offset by 3)\n *\n * @param index - Index in compassDirections array (0-23).\n * @returns True if cardinal or intercardinal direction.\n *\n * @example\n * isCardinalOrIntercardinal(0)  // true  (N)\n * isCardinalOrIntercardinal(3)  // true  (NE)\n * isCardinalOrIntercardinal(6)  // true  (E)\n * isCardinalOrIntercardinal(1)  // false (N⅓NE)\n */\nexport const isCardinalOrIntercardinal = (index: number): boolean => index % 3 === 0\n\n/**\n * Checks if a compass index represents a cardinal direction (N, E, S, W).\n *\n * @param index - Index in compassDirections array (0-23).\n * @returns True if cardinal direction.\n *\n * @example\n * isCardinal(0)  // true  (N)\n * isCardinal(6)  // true  (E)\n * isCardinal(12) // true  (S)\n * isCardinal(3)  // false (NE - intercardinal)\n */\nexport const isCardinal = (index: number): boolean => index % 6 === 0\n","import {\n    degreesFullCircle,\n    degreesHalfCircle,\n    degreesQuarterCircle,\n    mapSize,\n    speedFactor,\n    timeFactor,\n} from \"./constants.js\"\n\n// ============================================================================\n// Coordinate Transform Matrices\n// ============================================================================\n\n/**\n * Transform matrix for converting F11 coordinates to SVG coordinates.\n * This is a 2D affine transformation matrix.\n */\nconst transformMatrix = {\n    A: -0.004_998_667_793_638_28,\n    B: -0.000_000_214_642_549_806_45,\n    C: 4096.886_351_518_97,\n    D: 4096.902_827_874_69,\n} as const\n\n/**\n * Inverse transform matrix for converting SVG coordinates to F11 coordinates.\n */\nconst transformMatrixInv = {\n    A: -200.053_302_087_577,\n    B: -0.008_590_278_976_360_11,\n    C: 819_630.836_437_126,\n    D: -819_563.745_651_571,\n} as const\n\n// ============================================================================\n// Coordinate Conversion Functions\n// ============================================================================\n\n/**\n * Converts F11 game coordinates to SVG coordinates (X component).\n *\n * @param x - F11 X coordinate.\n * @param y - F11 Y coordinate.\n * @returns SVG X coordinate.\n */\nexport const convertCoordX = (x: number, y: number): number =>\n    transformMatrix.A * x + transformMatrix.B * y + transformMatrix.C\n\n/**\n * Converts F11 game coordinates to SVG coordinates (Y component).\n *\n * @param x - F11 X coordinate.\n * @param y - F11 Y coordinate.\n * @returns SVG Y coordinate.\n */\nexport const convertCoordY = (x: number, y: number): number =>\n    transformMatrix.B * x - transformMatrix.A * y + transformMatrix.D\n\n/**\n * Converts SVG coordinates to F11 game coordinates (X component).\n *\n * @param x - SVG X coordinate.\n * @param y - SVG Y coordinate.\n * @returns F11 X coordinate.\n */\nexport const convertInvCoordX = (x: number, y: number): number =>\n    transformMatrixInv.A * x + transformMatrixInv.B * y + transformMatrixInv.C\n\n/**\n * Converts SVG coordinates to F11 game coordinates (Y component).\n *\n * @param x - SVG X coordinate.\n * @param y - SVG Y coordinate.\n * @returns F11 Y coordinate.\n */\nexport const convertInvCoordY = (x: number, y: number): number =>\n    transformMatrixInv.B * x - transformMatrixInv.A * y + transformMatrixInv.D\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\n/**\n * Represents a 2D coordinate as an object with x and y properties.\n */\nexport interface Coordinate {\n    x: number\n    y: number\n}\n\n/**\n * Represents a distance between two ports.\n */\nexport interface Distance extends Array<number> {\n    0: number // From port id\n    1: number // To port id\n    2: number // Distance (in pixels)\n}\n\n/**\n * Represents a bounding box as two points [min, max].\n */\nexport type Extent = [Point, Point]\n\n/**\n * Represents a 2D point as a tuple [x, y].\n */\nexport interface Point extends Array<number> {\n    0: number // X coordinate\n    1: number // Y coordinate\n}\n\nexport type PointTuple = [number, number]\n\n// ============================================================================\n// Angle Conversion Functions\n// ============================================================================\n\n/**\n * Converts radians to degrees.\n *\n * @param radians - Angle in radians.\n * @returns Angle in degrees.\n *\n * @example\n * radiansToDegrees(Math.PI) // 180\n * radiansToDegrees(Math.PI / 2) // 90\n */\nexport const radiansToDegrees = (radians: number): number => (radians * degreesHalfCircle) / Math.PI\n\n/**\n * Converts degrees to radians, adjusted by -90° for compass orientation.\n *\n * @param degrees - Angle in degrees.\n * @returns Angle in radians.\n *\n * @example\n * degreesToRadians(90) // 0 (90° - 90° = 0°)\n * degreesToRadians(180) // π/2 (180° - 90° = 90°)\n */\nexport const degreesToRadians = (degrees: number): number =>\n    (Math.PI / degreesHalfCircle) * (degrees - degreesQuarterCircle)\n\n// ============================================================================\n// Angle Calculation Functions\n// ============================================================================\n\n/**\n * Calculates the angle in degrees between two points.\n * The angle is measured clockwise from north (up).\n *\n * @param centerPt - Center point (origin).\n * @param targetPt - Target point.\n * @returns Angle in degrees [0, 360).\n *\n * @example\n * rotationAngleInDegrees([0, 0], [0, -1]) // 0° (pointing up/north)\n * rotationAngleInDegrees([0, 0], [1, 0])  // 90° (pointing right/east)\n */\nexport const rotationAngleInDegrees = (centerPt: Point, targetPt: Point): number => {\n    // Calculate angle from horizontal axis\n    let theta = Math.atan2(targetPt[1] - centerPt[1], targetPt[0] - centerPt[0])\n\n    // Adjust to measure from vertical axis (north)\n    theta -= Math.PI / 2\n\n    // Convert to degrees\n    const degrees = radiansToDegrees(theta)\n\n    // Normalize to [0, 360)\n    return (degrees + degreesFullCircle) % degreesFullCircle\n}\n\n/**\n * Calculates the angle in radians between two points.\n *\n * @param centerPt - Center point (origin).\n * @param targetPt - Target point.\n * @returns Angle in radians.\n */\nexport const rotationAngleInRadians = (centerPt: Point, targetPt: Point): number =>\n    Math.atan2(centerPt[1], centerPt[0]) - Math.atan2(targetPt[1], targetPt[0])\n\n/**\n * Calculates the angle in radians from center point to target point.\n *\n * @param centerPt - Center point (origin).\n * @param targetPt - Target point.\n * @returns Angle in radians from horizontal axis.\n */\nexport const getRadians = (centerPt: Point, targetPt: Point): number =>\n    Math.atan2(targetPt[1] - centerPt[1], targetPt[0] - centerPt[0])\n\n/**\n * Calculates the angle in degrees from the origin to a point.\n * Result is normalized to [0, 360).\n *\n * @param x - X coordinate.\n * @param y - Y coordinate.\n * @returns Angle in degrees [0, 360).\n *\n * @example\n * getAngle(0, 1)   // 90°\n * getAngle(1, 0)   // 0°\n * getAngle(0, -1)  // 270°\n */\nexport const getAngle = (x: number, y: number): number => {\n    let theta = Math.atan2(y, x)\n    theta = Math.round((degreesHalfCircle / Math.PI) * theta)\n\n    // Normalize to [0, 360)\n    if (theta < 0) {\n        theta = degreesFullCircle + theta\n    }\n\n    return theta\n}\n\n/**\n * Adds two angles and normalizes the result to [0, 360).\n *\n * @param a - First angle in degrees.\n * @param b - Second angle in degrees.\n * @returns Sum of angles normalized to [0, 360).\n *\n * @example\n * addAngle(350, 20)  // 10° (wraps around)\n * addAngle(90, 45)   // 135°\n * addAngle(-45, 90)  // 45°\n */\nexport const addAngle = (a: number, b: number): number => {\n    let theta = a + b\n\n    // Normalize to [0, 360)\n    theta = ((theta % degreesFullCircle) + degreesFullCircle) % degreesFullCircle\n\n    return theta\n}\n\n// ============================================================================\n// Distance Functions\n// ============================================================================\n\n/**\n * Calculates the Euclidean distance between two points.\n *\n * @param centerPt - First point.\n * @param targetPt - Second point.\n * @returns Distance between the two points.\n *\n * @example\n * distancePoints({ x: 0, y: 0 }, { x: 3, y: 4 }) // 5\n */\nexport const distancePoints = (centerPt: Coordinate, targetPt: Coordinate): number =>\n    Math.hypot(centerPt.x - targetPt.x, centerPt.y - targetPt.y)\n\n/**\n * Calculates the game distance in kilometers between two SVG coordinates.\n * Converts SVG coordinates to F11 game coordinates and calculates the distance.\n *\n * @param pt0 - First point in SVG coordinates.\n * @param pt1 - Second point in SVG coordinates.\n * @returns Distance in game units (kilometers).\n *\n * @example\n * const portA = { x: 100, y: 200 }\n * const portB = { x: 300, y: 400 }\n * const distance = getDistance(portA, portB)\n */\nexport const getDistance = (pt0: Coordinate, pt1: Coordinate): number => {\n    // Convert SVG coordinates to F11 game coordinates\n    const fromF11 = {\n        x: convertInvCoordX(pt0.x, pt0.y),\n        y: convertInvCoordY(pt0.x, pt0.y),\n    }\n    const toF11 = {\n        x: convertInvCoordX(pt1.x, pt1.y),\n        y: convertInvCoordY(pt1.x, pt1.y),\n    }\n\n    // Calculate distance and convert to game units\n    return distancePoints(fromF11, toF11) / (timeFactor * speedFactor)\n}\n\n/**\n * Adjust for openlayers (top left is not [0,0] but [0,mapSize])\n */\nexport const coordinateAdjust = (x: number | PointTuple | PointTuple[], y?: number): PointTuple | PointTuple[] => {\n    if (Array.isArray(x)) {\n        return Array.isArray(x[0])\n            ? (x as PointTuple[]).map((element: PointTuple) => [element[0], mapSize - element[1]] as PointTuple)\n            : [(x as PointTuple)[0], mapSize - (x as PointTuple)[1]]\n    }\n\n    if (y != undefined) {\n        return [x, mapSize - y]\n    }\n\n    throw new Error(`Wrong parameters x: ${x}, y: ${y}`)\n}\n","import dayjs from \"dayjs\"\nimport customParseFormat from \"dayjs/plugin/customParseFormat\"\nimport utc from \"dayjs/plugin/utc\"\n\nimport { serverMaintenanceHour } from \"./constants.js\"\n\ndayjs.extend(customParseFormat)\ndayjs.extend(utc)\n\n/**\n * Gets the server start datetime for a given day offset.\n * The server \"day\" starts at serverMaintenanceHour UTC.\n *\n * @param dayOffset - Offset from current server day (0 = current, -1 = previous, 1 = next).\n * @returns The server start datetime.\n *\n * @example\n * // If current time is 2024-01-15 08:00 UTC (before 10:00)\n * getServerStartDateTime(0)  // Returns 2024-01-14 10:00 (current server day)\n * getServerStartDateTime(-1) // Returns 2024-01-13 10:00 (previous server day)\n * getServerStartDateTime(1)  // Returns 2024-01-15 10:00 (next server day)\n */\nconst getServerStartDateTime = (dayOffset: number): dayjs.Dayjs => {\n    const now = dayjs().utc()\n\n    // Start with today's maintenance hour\n    let serverStart = now.hour(serverMaintenanceHour).minute(0).second(0).millisecond(0)\n\n    // If we're before maintenance hour, current server day started yesterday\n    if (now.isBefore(serverStart)) {\n        serverStart = serverStart.subtract(1, \"day\")\n    }\n\n    // Apply the requested offset\n    if (dayOffset !== 0) {\n        serverStart = serverStart.add(dayOffset, \"day\")\n    }\n\n    return serverStart\n}\n\n/**\n * Get current server start (date and time).\n * This is the most recent maintenance time that has passed.\n */\nexport const getCurrentServerStart = (): dayjs.Dayjs => getServerStartDateTime(0)\n\n/**\n * Get previous server start (date and time).\n */\nexport const getPreviousServerStart = (): dayjs.Dayjs => getServerStartDateTime(-1)\n\n/**\n * Get next server start (date and time).\n */\nexport const getNextServerStart = (): dayjs.Dayjs => getServerStartDateTime(1)\n\n/**\n * Current server start datetime formatted as \"YYYY-MM-DD HH:mm\".\n */\nexport const currentServerStartDateTime = getCurrentServerStart().format(\"YYYY-MM-DD HH:mm\")\n\n/**\n * Current server start date formatted as \"YYYY-MM-DD\".\n */\nexport const currentServerStartDate = getCurrentServerStart().format(\"YYYY-MM-DD\")\n\n/**\n * Previous server start date formatted as \"YYYY-MM-DD\".\n */\nexport const previousServerStartDate = getPreviousServerStart().format(\"YYYY-MM-DD\")\n\n/**\n * Current server date year as a string.\n */\nexport const currentServerDateYear = String(getCurrentServerStart().year())\n\n/**\n * Current server date month as a zero-padded string (01-12).\n */\nexport const currentServerDateMonth = String(getCurrentServerStart().month() + 1).padStart(2, \"0\")\n","let currentLocale = \"en-GB\"\nconst localeChangeCallbacks: (() => void)[] = []\n\nexport const setLocale = (locale: string): void => {\n    if (currentLocale !== locale) {\n        currentLocale = locale\n        // Notify all registered callbacks\n        for (const callback of localeChangeCallbacks) callback()\n    }\n}\n\nexport const getLocale = (): string => currentLocale\n\n/**\n * Register a callback to be called whenever the locale changes.\n * @param callback - Function to call on locale change\n */\nexport const onLocaleChange = (callback: () => void): void => {\n    localeChangeCallbacks.push(callback)\n}\n","export const cCircleWhite = String.fromCodePoint(0x25_cb)\nexport const cCombiningDiaeresis = String.fromCodePoint(0x03_08)\nexport const cDashEm = String.fromCodePoint(0x20_14)\nexport const cDashEn = String.fromCodePoint(0x20_13)\nexport const cDashFigure = String.fromCodePoint(0x20_12)\nexport const cMinus = String.fromCodePoint(0x22_12)\nexport const cPlus = String.fromCodePoint(0x00_2b)\nexport const cPlusSmall = String.fromCodePoint(0xfe_62)\nexport const cSmallDot = String.fromCodePoint(0x00_b7)\nexport const cSpace = String.fromCodePoint(0x00_20)\nexport const cSpaceFigure = String.fromCodePoint(0x20_07)\nexport const cSpaceNarrowNoBreaking = String.fromCodePoint(0x20_2f)\nexport const cSpaceNoBreak = String.fromCodePoint(0x00_a0)\nexport const cSpacePunctuation = String.fromCodePoint(0x20_08)\nexport const cSpaceThin = String.fromCodePoint(0x20_09)\nexport const cSpaceZeroWidthBreaking = String.fromCodePoint(0xfe_ff)\nexport const cSpaceZeroWidthNoBreak = String.fromCodePoint(0xfe_ff)\n","import type { Dayjs } from \"dayjs\"\n\nimport \"dayjs/locale/de.js\"\nimport \"dayjs/locale/en.js\"\nimport \"dayjs/locale/en-gb.js\"\nimport dayjs from \"dayjs\"\nimport customParseFormat from \"dayjs/plugin/customParseFormat.js\"\nimport isBetween from \"dayjs/plugin/isBetween.js\"\nimport isSameOrBefore from \"dayjs/plugin/isSameOrBefore.js\"\nimport relativeTime from \"dayjs/plugin/relativeTime.js\"\nimport utc from \"dayjs/plugin/utc.js\"\n\nimport { getLocale, onLocaleChange, setLocale as setLibraryLocale } from \"../locale.js\"\nimport { cDashEn, cSpaceNoBreak } from \"../unicode.js\"\nimport { datetimeFormat } from \"./constants.js\"\n\ndayjs.extend(relativeTime)\ndayjs.extend(customParseFormat)\ndayjs.extend(isBetween)\ndayjs.extend(isSameOrBefore)\ndayjs.extend(relativeTime)\ndayjs.extend(utc)\n\n// Wrapper to sync dayjs locale with library locale\nexport const setDateLocale = (locale: string): void => {\n    setLibraryLocale(locale)\n    dayjs.locale(locale)\n}\n\n// Sync dayjs locale on any locale changes\nonLocaleChange(() => {\n    dayjs.locale(getLocale())\n})\n\n// Initialise with default\nsetDateLocale(\"en-GB\")\n\n/**\n * Formats date with locale-specific formatting.\n * @param date - Date string to format\n * @param locale - Optional locale override\n * @example getFormattedDate('2024-01-15') → \"Montag, 15. Januar, 14.30\" (de)\n * @example getFormattedDate('2024-01-15', 'en') → \"Monday, 15. January, 14.30\"\n */\nexport const getFormattedDate = (date: string, locale?: string): string => {\n    const effectiveLocale = locale ?? getLocale()\n    return dayjs(date).locale(effectiveLocale).format(\"dddd, D. MMMM, H.mm\")\n}\n\n/**\n * Short date format with day, month, and time.\n * @example getFormattedDateShort('2024-01-15') → \"15.1. 14.30\"\n */\nexport const getFormattedDateShort = (date: number | string, locale?: string): string => {\n    const effectiveLocale = locale ?? getLocale()\n    return dayjs(date).locale(effectiveLocale).format(\"D.M. H.mm\")\n}\n\n/**\n * Date format with seconds included.\n * @example getFormattedDateShortSeconds('2024-01-15') → \"15. Januar 14.30.45\"\n */\nexport const getFormattedDateShortSeconds = (date: number | string, locale?: string): string => {\n    const effectiveLocale = locale ?? getLocale()\n    return dayjs(date).locale(effectiveLocale).format(\"D. MMMM H.mm.ss\")\n}\n\n/**\n * Returns relative time string (e.g., \"vor 2 Stunden\" or \"2 hours ago\").\n * Uses currently active locale.\n */\nexport const getDateDistance = (date: string, locale?: string): string => {\n    const effectiveLocale = locale ?? getLocale()\n    return dayjs(date).locale(effectiveLocale).fromNow()\n}\n\n/**\n * Checks if the given date is in the future.\n */\nexport const isFutureDate = (date: Date | string): boolean => {\n    return dayjs().isBefore(date)\n}\n\n/**\n * Finds the index of the date closest to now.\n * @returns Index of closest date, or undefined if array is empty\n */\nexport const closestDateIndex = (datesString: string[]): number | undefined => {\n    if (datesString.length === 0) return undefined\n\n    const now = dayjs()\n    const dateDiffs = datesString.map((date) => Math.abs(now.diff(date)))\n    return dateDiffs.indexOf(Math.min(...dateDiffs))\n}\n\n// ============================================================================\n// Time Formatting\n// ============================================================================\n\n/**\n * Formats a datetime string as relative time (e.g., \"2 hours ago\").\n *\n * @param time - Datetime string in YYYY-MM-DD HH:mm format.\n * @returns Relative time string.\n *\n * @example\n * getRelativeTime(\"2024-01-15 10:00\") // \"2 hours ago\"\n */\nexport const getRelativeTime = (time: string): string => {\n    return dayjs.utc(time, datetimeFormat).fromNow()\n}\n\n/**\n * Checks if a datetime is in the past (or current moment).\n *\n * @param time - Datetime string in YYYY-MM-DD HH:mm format.\n * @returns True if the time is same or before now.\n *\n * @example\n * isPastDate(\"2024-01-15 10:00\") // true if current time is after this\n */\nexport const isPastDate = (time: string): boolean => {\n    return dayjs.utc(time, datetimeFormat).isSameOrBefore(dayjs.utc())\n}\n\n/**\n * Formats a datetime string in UTC.\n *\n * @param time - Datetime string in YYYY-MM-DD HH:mm format.\n * @returns Formatted UTC datetime string.\n *\n * @example\n * formatDate(\"2024-01-15 10:00\") // \"2024-01-15 10:00\"\n */\nexport const formatDate = (time: string): string => {\n    return dayjs.utc(time, datetimeFormat).format(datetimeFormat)\n}\n\n/**\n * Formats a datetime string as time only in UTC.\n *\n * @param time - Datetime string in YYYY-MM-DD HH:mm format.\n * @returns Formatted UTC time string (H:mm).\n *\n * @example\n * formatTime(\"2024-01-15 10:30\") // \"10:30\"\n */\nexport const formatTime = (time: string): string => {\n    return dayjs.utc(time, datetimeFormat).format(\"H:mm\")\n}\n\n/**\n * Formats a datetime string in local timezone.\n *\n * @param time - Datetime string in YYYY-MM-DD HH:mm format.\n * @returns Formatted local datetime string.\n *\n * @example\n * formatLocalDate(\"2024-01-15 10:00\") // \"2024-01-15 14:00\" (if local is UTC+4)\n */\nexport const formatLocalDate = (time: string): string => {\n    return dayjs.utc(time, datetimeFormat).local().format(datetimeFormat)\n}\n\n/**\n * Formats a datetime string as time only in local timezone.\n *\n * @param time - Datetime string in YYYY-MM-DD HH:mm format.\n * @returns Formatted local time string (H:mm).\n *\n * @example\n * formatLocalTime(\"2024-01-15 10:00\") // \"14:00\" (if local is UTC+4)\n */\nexport const formatLocalTime = (time: string): string => {\n    return dayjs.utc(time, datetimeFormat).local().format(\"H:mm\")\n}\n\n/**\n * Checks if a time falls within a given range.\n *\n * @param time - Datetime string in YYYY-MM-DD HH:mm format (or undefined).\n * @param begin - Start of the time range.\n * @param end - End of the time range.\n * @returns True if time is within range (exclusive start, inclusive end).\n *\n * @example\n * const begin = dayjs(\"2024-01-15 10:00\")\n * const end = dayjs(\"2024-01-15 20:00\")\n * isBetweenTime(\"2024-01-15 15:00\", begin, end) // true\n */\nexport const isBetweenTime = (time: string | undefined, begin: Dayjs, end: Dayjs): boolean => {\n    if (!time) return false\n    return dayjs(time, datetimeFormat).isBetween(begin, end, \"hour\", \"(]\")\n}\n\n/**\n * Converts a date range array to begin/end Dayjs objects.\n *\n * @param dateRange - Array of Date objects.\n * @returns Object with begin and end Dayjs objects.\n *\n * @example\n * const dates = [new Date(\"2024-01-01\"), new Date(\"2024-01-31\")]\n * const { begin, end } = getRange(dates)\n */\nexport const getRange = (dateRange: Date[]): { begin: Dayjs; end: Dayjs } => {\n    const begin = dayjs(dateRange[0])\n    const end = dayjs(dateRange.at(-1))\n    return { begin, end }\n}\n\n/**\n * Converts a UTC hour to local hour.\n *\n * @param hour - Hour in UTC (0-23).\n * @returns Hour in local timezone (0-23).\n */\nexport const getLocalHour = (hour: number): number => {\n    return Number(dayjs.utc().hour(hour).local().format(\"H\"))\n}\n\n/**\n * Formats a time range as HTML with non-breaking spaces.\n *\n * @param from - Starting hour.\n * @param to - Ending hour.\n * @returns HTML string with formatted time range.\n */\nexport const formatFromToTime = (from: number, to: number): string => {\n    return `<span class=\"text-no-wrap\">${from}${cSpaceNoBreak}${cDashEn}${cSpaceNoBreak}${to}</span>`\n}\n\n/**\n * Formats a time range showing both UTC and local times.\n *\n * @param from - Starting hour in UTC.\n * @param to - Ending hour in UTC.\n * @returns HTML string with UTC and local time ranges.\n */\nexport const formatTimeRange = (from: number, to: number): string => {\n    const fromLocal = getLocalHour(from)\n    const toLocal = getLocalHour(to)\n    return `${formatFromToTime(from, to)} (${formatFromToTime(fromLocal, toLocal)}${cSpaceNoBreak}local)`\n}\n","import dayjs from \"dayjs\"\nimport \"dayjs/locale/de\"\nimport \"dayjs/locale/en\"\nimport \"dayjs/locale/en-gb\"\nimport utc from \"dayjs/plugin/utc\"\n\nimport { formatTimeRange } from \"../date/date.js\"\nimport { getLocale, onLocaleChange, setLocale as setLibraryLocale } from \"../locale.js\"\nimport { hoursPerDay, maxPortBattleHour, serverMaintenanceHour } from \"./constants.js\"\n\ndayjs.extend(utc)\n\n// Wrapper to sync dayjs locale with library locale\nexport const setDateLocale = (locale: string): void => {\n    setLibraryLocale(locale)\n    dayjs.locale(locale)\n}\n\n// Sync dayjs locale on any locale changes\nonLocaleChange(() => {\n    dayjs.locale(getLocale())\n})\n\n// Initialise with default\nsetDateLocale(\"en-GB\")\n\n/**\n * Calculates and formats the port battle time window.\n *\n * @param startHoursFromSMH - Hours offset from server maintenance hour.\n * @param isNeutralPort - Whether this is a neutral port (9h window vs 2h).\n * @returns Formatted time range string with UTC and local times.\n *\n * @example\n * getPortBattleTime(0, false) // \"10 – 8 (14 – 12 local)\" (if local is UTC+4)\n * getPortBattleTime(2, true)  // \"12 – 21 (16 – 1 local)\" (9-hour neutral port window)\n */\nexport const getPortBattleTime = (startHoursFromSMH: number, isNeutralPort = false): string => {\n    const durationInHours = isNeutralPort ? 9 : 2\n    const startTime = (serverMaintenanceHour + startHoursFromSMH) % hoursPerDay\n\n    let endTime = serverMaintenanceHour + startHoursFromSMH + durationInHours\n    if (endTime > hoursPerDay) {\n        endTime = Math.min(\n            (serverMaintenanceHour + startHoursFromSMH + durationInHours) % hoursPerDay,\n            maxPortBattleHour,\n        )\n    }\n\n    return startHoursFromSMH === 0\n        ? formatTimeRange(serverMaintenanceHour, maxPortBattleHour)\n        : formatTimeRange(startTime, endTime)\n}\n\nexport const getToday = () => {\n    const now = dayjs.utc()\n    let begin = dayjs().utc().hour(serverMaintenanceHour).minute(0)\n    if (now.hour() < begin.hour()) {\n        begin = begin.subtract(1, \"day\")\n    }\n\n    const end = begin.add(1, \"day\")\n\n    return { begin, end }\n}\n\nexport const getYesterday = () => {\n    const now = dayjs.utc()\n    let begin = now.hour(serverMaintenanceHour).minute(0).subtract(1, \"day\")\n    if (now.hour() < begin.hour()) {\n        begin = begin.subtract(1, \"day\")\n    }\n\n    const end = begin.add(1, \"day\")\n\n    return { begin, end }\n}\n\nexport const getThisWeek = () => {\n    const currentMondayOfWeek = dayjs().utc().startOf(\"week\")\n    // This Monday\n    const begin = currentMondayOfWeek.hour(serverMaintenanceHour)\n    // Next Monday\n    const end = currentMondayOfWeek.add(7, \"day\").hour(serverMaintenanceHour)\n\n    return { begin, end }\n}\n\nexport const getLastWeek = () => {\n    const currentMondayOfWeek = dayjs().utc().startOf(\"week\")\n    // Monday last week\n    const begin = currentMondayOfWeek.subtract(7, \"day\").hour(serverMaintenanceHour)\n    // This Monday\n    const end = currentMondayOfWeek.hour(serverMaintenanceHour)\n\n    return { begin, end }\n}\n","import { degreesFullCircle } from \"./constants.js\"\n\n/**\n * Number of segments to divide the wind rose/compass into.\n */\nexport const numberSegments = 24\n\n/**\n * Radians per segment of the wind rose.\n * Calculated as (2π / numberSegments).\n */\nexport const segmentRadians = (2 * Math.PI) / numberSegments\n\n/**\n * Factor used for scaling the wind rose circle radius.\n */\nexport const circleRadiusFactor = 5\n\n/**\n * Duration in seconds for a complete wind cycle (360° rotation).\n * Represents 48 minutes and 55 seconds.\n */\nconst secondsForFullCircle = 2935 // 48 * 60 + 55\n\n/**\n * Degrees the wind rotates per second.\n * Calculated as 360° / secondsForFullCircle.\n */\nexport const degreesPerSecond = degreesFullCircle / secondsForFullCircle\n\n/**\n * Subtracts a value from a wind direction and normalizes to 0-360° range.\n *\n * @param wind - Current wind direction in degrees (0-360).\n * @param sub - Value to subtract (will be normalized with modulo 360).\n * @returns Normalized wind direction in the range [0, 360).\n *\n * @example\n * subtractFromWind(90, 45)   // 45\n * subtractFromWind(30, 90)   // 300 (wraps around)\n * subtractFromWind(180, 540) // 0 (540 % 360 = 180, 180 - 180 = 0)\n */\nexport const subtractFromWind = (wind: number, sub: number): number => {\n    // Normalize the subtraction value to 0-360 range\n    const normalizedSub = sub % 360\n\n    // Perform subtraction\n    let result = Math.round(wind - normalizedSub)\n\n    // Normalize result to [0, 360) range\n    while (result >= 360) {\n        result -= 360\n    }\n    while (result < 0) {\n        result += 360\n    }\n\n    return result\n}\n\n/**\n * Alternative implementation using modulo for normalization.\n * Mathematically equivalent but more concise.\n *\n * @param wind - Current wind direction in degrees (0-360).\n * @param sub - Value to subtract.\n * @returns Normalized wind direction in the range [0, 360).\n */\nexport const subtractFromWindAlt = (wind: number, sub: number): number => {\n    const result = Math.round(wind - (sub % 360))\n    return ((result % 360) + 360) % 360\n}\n"],"mappings":"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"}