import{execFile as e,execFileSync as t,execSync as n}from"node:child_process";import{promisify as r}from"node:util";import i from"node:fs";import a from"node:fs/promises";import{readFileSync as o,writeFile as s,writeFileSync as c}from"atomically";import l from"node:path";const u={addressInUse:`EADDRINUSE`,brokenPipe:`EPIPE`,connectionRefused:`ECONNREFUSED`,directoryNotEmpty:`ENOTEMPTY`,fileExists:`EEXIST`,fileNotFound:`ENOENT`,invalidArgument:`EINVAL`,noSpaceLeft:`ENOSPC`,operationNotPermitted:`EPERM`,permissionDenied:`EACCES`,readOnlyFileSystem:`EROFS`,timeout:`ETIMEDOUT`,tooManyOpenFiles:`EMFILE`},d=e=>{let t=e instanceof Error?e.message:String(e);console.error(`Request failed -->`,t)},f=e=>e instanceof Error&&`code`in e,p=`utf8`,m=r(e),h=(e,t)=>{f(t)?t.code===`ENOENT`?(console.error(`Command not found:`,e),console.error(`Error details:`,t.message)):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code),console.error(`Error details:`,t.message)):d(String(t))},g=(e,t)=>{try{return n(e,{...t,encoding:p})}catch(t){return h(e,t),``}},ee=(e,t)=>{try{return{output:n(e,{...t,encoding:p}),success:!0}}catch(t){let n=t instanceof Error?t:Error(String(t));return f(t)&&(t.code===`ENOENT`?console.error(`Command not found:`,e):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code))),{error:n,output:void 0,success:!1}}},te=(e,t)=>g(e,t).trim(),ne=e=>{try{return t(process.platform===`win32`?`where`:`which`,[e],{stdio:`ignore`}),!0}catch{return!1}},re=async(e,t)=>{try{let{stdout:n}=await m(e,{...t,encoding:p,shell:!0});return n.trim()}catch(t){return h(e,t),``}},_=async(e,t)=>{try{let{stderr:n,stdout:r}=await m(e,{...t,encoding:p,shell:!0});return{stderr:n.trim(),stdout:r.trim(),success:!0}}catch(t){let n=t instanceof Error?t:Error(String(t)),r=``,i=``;return t&&typeof t==`object`&&`stdout`in t&&`stderr`in t&&typeof t.stdout==`string`&&typeof t.stderr==`string`&&(r=t.stdout,i=t.stderr),f(t)&&(t.code===`ENOENT`?console.error(`Command not found:`,e):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code))),{error:n,stderr:i.trim(),stdout:r.trim(),success:!1}}},v=async e=>{try{return await m(process.platform===`win32`?`where`:`which`,[e]),!0}catch{return!1}},y=e=>{try{return i.statSync(e,{throwIfNoEntry:!1})}catch(e){d(e);return}},b=async e=>{try{return await a.stat(e)}catch(e){d(e);return}},x=e=>y(e)!==void 0,S=async e=>await b(e)!==void 0,C=(e,t)=>{let n=y(e),r=y(t);return!n||!r?!1:n.mtime<r.mtime},w=async(e,t)=>{let n=await b(e),r=await b(t);return!n||!r?!1:n.mtime<r.mtime},T=e=>{try{i.mkdirSync(e,{recursive:!0})}catch(t){d(`Cannot create directory ${e}\nError: ${String(t)}`)}},E=async e=>{try{await a.mkdir(e,{recursive:!0})}catch(t){d(`Cannot create directory ${e}\nError: ${String(t)}`)}},ie=e=>i.readdirSync(e,{recursive:!0}),ae=async e=>await a.readdir(e,{recursive:!0}),D=e=>i.readdirSync(e,{recursive:!1}),O=async e=>await a.readdir(e,{recursive:!1}),k=e=>{i.rmSync(e,{force:!0,recursive:!0})},A=async e=>{await a.rm(e,{force:!0,recursive:!0})},j=e=>y(e)?.isDirectory()===!0,M=async e=>{try{return(await a.stat(e)).isDirectory()}catch{return!1}},N=e=>{try{return o(e,{encoding:p})}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},P=async e=>{try{return await a.readFile(e,{encoding:p})}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},F=(e,t)=>{try{c(e,t,{encoding:p})}catch(t){d(`Cannot save ${e} (atomically.writeFileSync)\nError: ${String(t)}`)}},I=async(e,t)=>{try{await s(e,t,{encoding:p})}catch(t){d(`Cannot save ${e} (atomically.writeFile)\nError: ${String(t)}`)}},L=e=>{try{let t=N(e);return t===void 0?void 0:JSON.parse(t)}catch(e){d(e);return}},R=async e=>{try{let t=await P(e);return t===void 0?void 0:JSON.parse(t)}catch(e){d(e);return}},z=(e,t)=>{F(e,JSON.stringify(t))},B=async(e,t)=>{await I(e,JSON.stringify(t))},V=e=>{try{return o(e)}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},H=async e=>{try{return await a.readFile(e)}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},U=(e,t)=>{try{c(e,t)}catch(t){d(`Cannot save ${e} (saveBinaryFileSync)\nError: ${String(t)}`)}},W=async(e,t)=>{try{await s(e,t)}catch(t){d(`Cannot save ${e} (saveBinaryFileAsync)\nError: ${String(t)}`)}},G=e=>V(e),K=async e=>H(e),q=(e,t)=>{U(e,t)},J=async(e,t)=>{await W(e,t)},Y={force:!0,throwIfNoEntry:!1},oe=e=>{i.rmSync(e,{force:Y.force})},se=async e=>{try{await a.rm(e,{force:Y.force})}catch(e){d(e)}},X=e=>y(e)?.isFile()===!0,ce=e=>i.statSync(e,{throwIfNoEntry:Y.throwIfNoEntry})?.size===0,le=async e=>{try{return(await a.stat(e)).isFile()}catch{return!1}},ue=e=>y(e)?.size,Z=e=>{try{return i.statfsSync(e)}catch(e){d(e);return}},Q=async e=>{try{return await a.statfs(e)}catch(e){d(e);return}},$=e=>{if(!e)return;let t=e.bsize*e.blocks,n=e.bsize*e.bavail,r=e.bsize*(e.blocks-e.bfree);return{free:n,percentUsed:t>0?r/t*100:0,total:t,used:r}},de=e=>$(Z(e))?.free,fe=async e=>$(await Q(e))?.free,pe=e=>$(Z(e))?.total,me=async e=>$(await Q(e))?.total,he=e=>$(Z(e))?.used,ge=async e=>$(await Q(e))?.used,_e=e=>$(Z(e)),ve=async e=>$(await Q(e)),ye=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:t.startsWith(`.`)?t:`.${t}`,name:n.name})},be=e=>{let t=l.parse(e);return l.join(t.dir,t.name)},xe=e=>l.extname(e),Se=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:n.ext,name:n.name+t})},Ce=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:n.ext,name:t+n.name})},we=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:n.ext,name:t})},Te=e=>l.parse(e).name,Ee=e=>l.basename(e),De=e=>l.join(e.dir,e.base),Oe=e=>l.dirname(e),ke=(e,t)=>l.join(e,t);export{Se as appendToFileName,ye as changeExtension,we as changeFileName,ne as commandExists,v as commandExistsAsync,p as defaultEncoding,j as directoryExists,M as directoryExistsAsync,u as errorCodes,g as executeCommand,re as executeCommandAsync,_ as executeCommandAsyncWithResult,te as executeCommandString,ee as executeCommandWithResult,ce as fileEmpty,X as fileExists,le as fileExistsAsync,Oe as getDirectory,_e as getDiskUsage,ve as getDiskUsageAsync,xe as getExtension,Te as getFileName,Ee as getFileNameWithExtension,ue as getFileSize,de as getFreeSpace,fe as getFreeSpaceAsync,De as getFullPath,b as getStatAsync,y as getStatSync,pe as getTotalSpace,me as getTotalSpaceAsync,he as getUsedSpace,ge as getUsedSpaceAsync,C as isFileOlderThan,w as isFileOlderThanAsync,f as isNodeError,ke as joinPaths,E as makeDirectoryAsync,T as makeDirectorySync,x as pathExists,S as pathExistsAsync,Ce as prependToFileName,d as putError,H as readBinaryFileAsync,V as readBinaryFileSync,ae as readDirectoryAsync,D as readDirectoryNotRecursive,O as readDirectoryNotRecursiveAsync,ie as readDirectorySync,K as readImageAsync,G as readImageSync,R as readJsonAsync,L as readJsonSync,P as readTextFileAsync,N as readTextFileSync,A as removeDirectoryAsync,k as removeDirectorySync,be as removeExtension,se as removeFileAsync,oe as removeFileSync,W as saveBinaryFileAsync,U as saveBinaryFileSync,J as saveImageAsync,q as saveImageSync,B as saveJsonAsync,z as saveJsonSync,I as saveTextFileAsync,F as saveTextFileSync};
//# sourceMappingURL=node.mjs.map