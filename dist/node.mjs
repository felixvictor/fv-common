import{execFile as e,execFileSync as t,execSync as n}from"node:child_process";import{promisify as r}from"node:util";import i from"node:fs";import a from"node:fs/promises";import{readFileSync as o,writeFile as s,writeFileSync as c}from"atomically";import l from"node:path";const u={addressInUse:`EADDRINUSE`,brokenPipe:`EPIPE`,connectionRefused:`ECONNREFUSED`,directoryNotEmpty:`ENOTEMPTY`,fileExists:`EEXIST`,fileNotFound:`ENOENT`,invalidArgument:`EINVAL`,noSpaceLeft:`ENOSPC`,operationNotPermitted:`EPERM`,permissionDenied:`EACCES`,readOnlyFileSystem:`EROFS`,timeout:`ETIMEDOUT`,tooManyOpenFiles:`EMFILE`},d=e=>{let t=e instanceof Error?e.message:String(e);console.error(`Request failed -->`,t)},f=e=>e instanceof Error&&`code`in e,p=`utf8`,m=r(e),h=(e,t)=>{f(t)?t.code===`ENOENT`?(console.error(`Command not found:`,e),console.error(`Error details:`,t.message)):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code),console.error(`Error details:`,t.message)):d(String(t))},g=(e,t)=>{try{return n(e,{...t,encoding:p})}catch(t){return h(e,t),``}},ee=(e,t)=>{try{return{output:n(e,{...t,encoding:p}),success:!0}}catch(t){let n=t instanceof Error?t:Error(String(t));return f(t)&&(t.code===`ENOENT`?console.error(`Command not found:`,e):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code))),{error:n,output:void 0,success:!1}}},_=(e,t)=>g(e,t).trim(),te=e=>{try{return t(process.platform===`win32`?`where`:`which`,[e],{stdio:`ignore`}),!0}catch{return!1}},v=async(e,t)=>{try{let{stdout:n}=await m(e,{...t,encoding:p,shell:!0});return n.trim()}catch(t){return h(e,t),``}},y=async(e,t)=>{try{let{stderr:n,stdout:r}=await m(e,{...t,encoding:p,shell:!0});return{stderr:n.trim(),stdout:r.trim(),success:!0}}catch(t){let n=t instanceof Error?t:Error(String(t)),r=``,i=``;return t&&typeof t==`object`&&`stdout`in t&&`stderr`in t&&typeof t.stdout==`string`&&typeof t.stderr==`string`&&(r=t.stdout,i=t.stderr),f(t)&&(t.code===`ENOENT`?console.error(`Command not found:`,e):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code))),{error:n,stderr:i.trim(),stdout:r.trim(),success:!1}}},b=async e=>{try{return await m(process.platform===`win32`?`where`:`which`,[e]),!0}catch{return!1}},x=e=>{try{return i.statSync(e,{throwIfNoEntry:!1})}catch(e){d(e);return}},S=async e=>{try{return await a.stat(e)}catch(e){d(e);return}},C=e=>x(e)!==void 0,w=async e=>await S(e)!==void 0,T=e=>{try{i.mkdirSync(e,{recursive:!0})}catch(t){d(`Cannot create directory ${e}\nError: ${String(t)}`)}},E=async e=>{try{await a.mkdir(e,{recursive:!0})}catch(t){d(`Cannot create directory ${e}\nError: ${String(t)}`)}},D=e=>i.readdirSync(e,{recursive:!0}),O=async e=>await a.readdir(e,{recursive:!0}),ne=e=>i.readdirSync(e,{recursive:!1}),re=async e=>await a.readdir(e,{recursive:!1}),k=e=>{i.rmSync(e,{force:!0,recursive:!0})},A=async e=>{await a.rm(e,{force:!0,recursive:!0})},j=e=>x(e)?.isDirectory()===!0,M=async e=>{try{return(await a.stat(e)).isDirectory()}catch{return!1}},N=e=>{try{return o(e,{encoding:p})}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},P=async e=>{try{return await a.readFile(e,{encoding:p})}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},F=(e,t)=>{try{c(e,t,{encoding:p})}catch(t){d(`Cannot save ${e} (atomically.writeFileSync)\nError: ${String(t)}`)}},I=async(e,t)=>{try{await s(e,t,{encoding:p})}catch(t){d(`Cannot save ${e} (atomically.writeFile)\nError: ${String(t)}`)}},L=e=>{try{let t=N(e);return t===void 0?void 0:JSON.parse(t)}catch(e){d(e);return}},R=async e=>{try{let t=await P(e);return t===void 0?void 0:JSON.parse(t)}catch(e){d(e);return}},z=(e,t)=>{F(e,JSON.stringify(t))},B=async(e,t)=>{await I(e,JSON.stringify(t))},V=e=>{try{return o(e)}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},H=async e=>{try{return await a.readFile(e)}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},U=(e,t)=>{try{c(e,t)}catch(t){d(`Cannot save ${e} (saveBinaryFileSync)\nError: ${String(t)}`)}},W=async(e,t)=>{try{await s(e,t)}catch(t){d(`Cannot save ${e} (saveBinaryFileAsync)\nError: ${String(t)}`)}},G=e=>V(e),K=async e=>H(e),q=(e,t)=>{U(e,t)},J=async(e,t)=>{await W(e,t)},Y={force:!0,throwIfNoEntry:!1},X=e=>{i.rmSync(e,{force:Y.force})},ie=async e=>{try{await a.rm(e,{force:Y.force})}catch(e){d(e)}},ae=e=>x(e)?.isFile()===!0,oe=e=>i.statSync(e,{throwIfNoEntry:Y.throwIfNoEntry})?.size===0,se=async e=>{try{return(await a.stat(e)).isFile()}catch{return!1}},ce=e=>x(e)?.size,Z=e=>{try{return i.statfsSync(e)}catch(e){d(e);return}},Q=async e=>{try{return await a.statfs(e)}catch(e){d(e);return}},$=e=>{if(!e)return;let t=e.bsize*e.blocks,n=e.bsize*e.bavail,r=e.bsize*(e.blocks-e.bfree);return{free:n,percentUsed:t>0?r/t*100:0,total:t,used:r}},le=e=>$(Z(e))?.free,ue=async e=>$(await Q(e))?.free,de=e=>$(Z(e))?.total,fe=async e=>$(await Q(e))?.total,pe=e=>$(Z(e))?.used,me=async e=>$(await Q(e))?.used,he=e=>$(Z(e)),ge=async e=>$(await Q(e)),_e=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:t.startsWith(`.`)?t:`.${t}`,name:n.name})},ve=e=>{let t=l.parse(e);return l.join(t.dir,t.name)},ye=e=>l.extname(e),be=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:n.ext,name:n.name+t})},xe=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:n.ext,name:t+n.name})},Se=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:n.ext,name:t})},Ce=e=>l.parse(e).name,we=e=>l.basename(e),Te=e=>l.join(e.dir,e.base),Ee=e=>l.dirname(e),De=(e,t)=>l.join(e,t);export{be as appendToFileName,_e as changeExtension,Se as changeFileName,te as commandExists,b as commandExistsAsync,p as defaultEncoding,j as directoryExists,M as directoryExistsAsync,u as errorCodes,g as executeCommand,v as executeCommandAsync,y as executeCommandAsyncWithResult,_ as executeCommandString,ee as executeCommandWithResult,oe as fileEmpty,ae as fileExists,se as fileExistsAsync,Ee as getDirectory,he as getDiskUsage,ge as getDiskUsageAsync,ye as getExtension,Ce as getFileName,we as getFileNameWithExtension,ce as getFileSize,le as getFreeSpace,ue as getFreeSpaceAsync,Te as getFullPath,S as getStatAsync,x as getStatSync,de as getTotalSpace,fe as getTotalSpaceAsync,pe as getUsedSpace,me as getUsedSpaceAsync,f as isNodeError,De as joinPaths,E as makeDirectoryAsync,T as makeDirectorySync,C as pathExists,w as pathExistsAsync,xe as prependToFileName,d as putError,H as readBinaryFileAsync,V as readBinaryFileSync,O as readDirectoryAsync,ne as readDirectoryNotRecursive,re as readDirectoryNotRecursiveAsync,D as readDirectorySync,K as readImageAsync,G as readImageSync,R as readJsonAsync,L as readJsonSync,P as readTextFileAsync,N as readTextFileSync,A as removeDirectoryAsync,k as removeDirectorySync,ve as removeExtension,ie as removeFileAsync,X as removeFileSync,W as saveBinaryFileAsync,U as saveBinaryFileSync,J as saveImageAsync,q as saveImageSync,B as saveJsonAsync,z as saveJsonSync,I as saveTextFileAsync,F as saveTextFileSync};
//# sourceMappingURL=node.mjs.map