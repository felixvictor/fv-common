import{exec as e,execSync as t}from"node:child_process";import{promisify as n}from"node:util";import r from"node:fs";import i from"node:fs/promises";import{readFileSync as a,writeFile as o,writeFileSync as s}from"atomically";import c from"node:path";const l={fileNotFound:`ENOENT`},u=e=>{let t=e instanceof Error?e.message:String(e);console.error(`Request failed -->`,t)},d=e=>e instanceof Error&&`code`in e,f=n(e),p=(e,t)=>{d(t)?t.code===`ENOENT`?(console.error(`Command not found:`,e),console.error(`Error details:`,t.message)):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code),console.error(`Error details:`,t.message)):u(String(t))},m=(e,n)=>{try{return t(e,{...n,encoding:void 0})}catch(t){return p(e,t),Buffer.from(``)}},h=(e,n)=>{try{return{output:t(e,{...n,encoding:void 0}),success:!0}}catch(t){let n=t instanceof Error?t:Error(String(t));return d(t)&&(t.code===`ENOENT`?console.error(`Command not found:`,e):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code))),{error:n,output:void 0,success:!1}}},g=(e,t)=>m(e,t).toString().trim(),_=e=>{try{return t(`${process.platform===`win32`?`where`:`which`} ${e}`,{stdio:`ignore`}),!0}catch{return!1}},v=async(e,t)=>{try{let{stdout:n}=await f(e,{...t,encoding:`utf8`});return n.trim()}catch(t){return p(e,t),``}},y=async(e,t)=>{try{let{stderr:n,stdout:r}=await f(e,{...t,encoding:`utf8`});return{stderr:n.trim(),stdout:r.trim(),success:!0}}catch(t){let n=t instanceof Error?t:Error(String(t)),r=``,i=``;return t&&typeof t==`object`&&`stdout`in t&&`stderr`in t&&typeof t.stdout==`string`&&typeof t.stderr==`string`&&(r=t.stdout,i=t.stderr),d(t)&&(t.code===`ENOENT`?console.error(`Command not found:`,e):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code))),{error:n,stderr:i.trim(),stdout:r.trim(),success:!1}}},b=async e=>{try{return await f(`${process.platform===`win32`?`where`:`which`} ${e}`),!0}catch{return!1}},x=e=>{try{r.mkdirSync(e,{recursive:!0})}catch(t){u(`Cannot make directory ${e}\nError: ${String(t)}`)}},S=async e=>{try{await i.mkdir(e,{recursive:!0})}catch(t){u(`Cannot make directory ${e}\nError: ${String(t)}`)}},C=e=>r.readdirSync(e,{recursive:!0}),w=e=>{r.rmSync(e,{force:!0,recursive:!0})},T=`utf8`,E=async(e,t)=>{try{await o(e,t,{encoding:T})}catch(t){u(`Cannot save ${e} (atomically.writeFile)\nError: ${String(t)}`)}},D=(e,t)=>{try{s(e,t,{encoding:T})}catch(t){u(`Cannot save ${e} (atomically.writeFileSync)\nError: ${String(t)}`)}},O=async(e,t)=>{await E(e,JSON.stringify(t))},k=(e,t)=>{D(e,JSON.stringify(t))},A=(e,t)=>{try{s(e,t)}catch(t){u(`Cannot save ${e} (saveBinaryFile)\nError: ${String(t)}`)}},j=(e,t)=>{A(e,t)},M=e=>{try{return a(e,{encoding:T})}catch(t){d(t)&&t.code===l.fileNotFound?u(`File ${e} not found`):u(t);return}},N=e=>{try{let t=M(e);return t===void 0?void 0:JSON.parse(t)}catch(e){u(e);return}},P=async e=>{try{return await i.readFile(e,{encoding:T})}catch(t){d(t)&&t.code===l.fileNotFound?u(`File ${e} not found`):u(t);return}},F={force:!0,throwIfNoEntry:!1},I=e=>{r.rmSync(e,{force:F.force})},L=async e=>{try{await i.rm(e,{force:F.force})}catch(e){u(e)}},R=e=>{try{return r.statSync(e).isFile()}catch{return!1}},z=e=>r.statSync(e,{throwIfNoEntry:F.throwIfNoEntry})?.size===0,B=async e=>{try{return(await i.stat(e)).isFile()}catch{return!1}},V=(e,t)=>{let n=c.parse(e);return c.format({dir:n.dir,ext:t.startsWith(`.`)?t:`.${t}`,name:n.name})},H=(e,t)=>{let n=c.parse(e);return c.format({dir:n.dir,ext:n.ext,name:n.name+t})},U=(e,t)=>{let n=c.parse(e);return c.format({dir:n.dir,ext:n.ext,name:t})};export{H as appendToFileName,V as changeExtension,U as changeFileName,_ as commandExists,b as commandExistsAsync,l as errorCodes,m as executeCommand,v as executeCommandAsync,y as executeCommandAsyncWithResult,g as executeCommandString,h as executeCommandWithResult,z as fileEmpty,R as fileExists,B as fileExistsAsync,d as isNodeError,S as makeDirectoryAsync,x as makeDirectorySync,u as putError,C as readDirectorySync,N as readJsonSync,P as readTextFileAsync,M as readTextFileSync,w as removeDirectorySync,L as removeFileAsync,I as removeFileSync,A as saveBinaryFile,j as saveImage,k as saveJson,O as saveJsonAsync,E as saveTextFileAsync,D as saveTextFileSync};
//# sourceMappingURL=node.mjs.map