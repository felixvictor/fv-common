import{execFile as e,execFileSync as t,execSync as n}from"node:child_process";import{promisify as r}from"node:util";import i from"node:fs";import a from"node:fs/promises";import{readFileSync as o,writeFile as s,writeFileSync as c}from"atomically";import l from"node:path";const u={addressInUse:`EADDRINUSE`,brokenPipe:`EPIPE`,connectionRefused:`ECONNREFUSED`,directoryNotEmpty:`ENOTEMPTY`,fileExists:`EEXIST`,fileNotFound:`ENOENT`,invalidArgument:`EINVAL`,noSpaceLeft:`ENOSPC`,operationNotPermitted:`EPERM`,permissionDenied:`EACCES`,readOnlyFileSystem:`EROFS`,timeout:`ETIMEDOUT`,tooManyOpenFiles:`EMFILE`},d=e=>{let t=e instanceof Error?e.message:String(e);console.error(`Request failed -->`,t)},f=e=>e instanceof Error&&`code`in e,p=`utf8`,m=r(e),h=(e,t)=>{f(t)?t.code===`ENOENT`?(console.error(`Command not found:`,e),console.error(`Error details:`,t.message)):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code),console.error(`Error details:`,t.message)):d(String(t))},g=(e,t)=>{try{return n(e,{...t,encoding:p})}catch(t){return h(e,t),``}},ee=(e,t)=>{try{return{output:n(e,{...t,encoding:p}),success:!0}}catch(t){let n=t instanceof Error?t:Error(String(t));return f(t)&&(t.code===`ENOENT`?console.error(`Command not found:`,e):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code))),{error:n,output:void 0,success:!1}}},te=(e,t)=>g(e,t).trim(),ne=e=>{try{return t(process.platform===`win32`?`where`:`which`,[e],{stdio:`ignore`}),!0}catch{return!1}},_=async(e,t)=>{try{let{stdout:n}=await m(e,{...t,encoding:p,shell:!0});return n.trim()}catch(t){return h(e,t),``}},v=async(e,t)=>{try{let{stderr:n,stdout:r}=await m(e,{...t,encoding:p,shell:!0});return{stderr:n.trim(),stdout:r.trim(),success:!0}}catch(t){let n=t instanceof Error?t:Error(String(t)),r=``,i=``;return t&&typeof t==`object`&&`stdout`in t&&`stderr`in t&&typeof t.stdout==`string`&&typeof t.stderr==`string`&&(r=t.stdout,i=t.stderr),f(t)&&(t.code===`ENOENT`?console.error(`Command not found:`,e):(console.error(`Command execution failed:`,e),console.error(`Error code:`,t.code))),{error:n,stderr:i.trim(),stdout:r.trim(),success:!1}}},y=async e=>{try{return await m(process.platform===`win32`?`where`:`which`,[e]),!0}catch{return!1}},b=e=>{try{return i.statSync(e,{throwIfNoEntry:!1})}catch(e){d(e);return}},x=async e=>{try{return await a.stat(e)}catch(e){d(e);return}},S=e=>b(e)!==void 0,C=async e=>await x(e)!==void 0,w=e=>{try{i.mkdirSync(e,{recursive:!0})}catch(t){d(`Cannot create directory ${e}\nError: ${String(t)}`)}},T=async e=>{try{await a.mkdir(e,{recursive:!0})}catch(t){d(`Cannot create directory ${e}\nError: ${String(t)}`)}},E=e=>i.readdirSync(e,{recursive:!0}),D=async e=>await a.readdir(e,{recursive:!0}),re=e=>i.readdirSync(e,{recursive:!1}),ie=async e=>await a.readdir(e,{recursive:!1}),O=e=>{i.rmSync(e,{force:!0,recursive:!0})},k=async e=>{await a.rm(e,{force:!0,recursive:!0})},A=e=>b(e)?.isDirectory()===!0,j=async e=>{try{return(await a.stat(e)).isDirectory()}catch{return!1}},M=e=>{try{return o(e,{encoding:p})}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},N=async e=>{try{return await a.readFile(e,{encoding:p})}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},P=(e,t)=>{try{c(e,t,{encoding:p})}catch(t){d(`Cannot save ${e} (atomically.writeFileSync)\nError: ${String(t)}`)}},F=async(e,t)=>{try{await s(e,t,{encoding:p})}catch(t){d(`Cannot save ${e} (atomically.writeFile)\nError: ${String(t)}`)}},I=e=>{try{let t=M(e);return t===void 0?void 0:JSON.parse(t)}catch(e){d(e);return}},L=async e=>{try{let t=await N(e);return t===void 0?void 0:JSON.parse(t)}catch(e){d(e);return}},R=(e,t)=>{P(e,JSON.stringify(t))},z=async(e,t)=>{await F(e,JSON.stringify(t))},B=e=>{try{return o(e)}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},V=async e=>{try{return await a.readFile(e)}catch(t){f(t)&&t.code===u.fileNotFound?d(`File ${e} not found`):d(t);return}},H=(e,t)=>{try{c(e,t)}catch(t){d(`Cannot save ${e} (saveBinaryFileSync)\nError: ${String(t)}`)}},U=async(e,t)=>{try{await s(e,t)}catch(t){d(`Cannot save ${e} (saveBinaryFileAsync)\nError: ${String(t)}`)}},W=e=>B(e),G=async e=>V(e),K=(e,t)=>{H(e,t)},q=async(e,t)=>{await U(e,t)},J={force:!0,throwIfNoEntry:!1},Y=e=>{i.rmSync(e,{force:J.force})},ae=async e=>{try{await a.rm(e,{force:J.force})}catch(e){d(e)}},oe=e=>b(e)?.isFile()===!0,se=e=>i.statSync(e,{throwIfNoEntry:J.throwIfNoEntry})?.size===0,ce=async e=>{try{return(await a.stat(e)).isFile()}catch{return!1}},le=e=>b(e)?.size,X=e=>{try{return i.statfsSync(e)}catch(e){d(e);return}},Z=async e=>{try{return await a.statfs(e)}catch(e){d(e);return}},Q=e=>{if(!e)return;let t=e.bsize*e.blocks,n=e.bsize*e.bavail,r=e.bsize*(e.blocks-e.bfree);return{free:n,percentUsed:t>0?r/t*100:0,total:t,used:r}},ue=e=>Q(X(e))?.free,de=async e=>Q(await Z(e))?.free,fe=e=>Q(X(e))?.total,pe=async e=>Q(await Z(e))?.total,$=e=>Q(X(e))?.used,me=async e=>Q(await Z(e))?.used,he=e=>Q(X(e)),ge=async e=>Q(await Z(e)),_e=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:t.startsWith(`.`)?t:`.${t}`,name:n.name})},ve=e=>{let t=l.parse(e);return l.join(t.dir,t.name)},ye=e=>l.extname(e),be=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:n.ext,name:n.name+t})},xe=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:n.ext,name:t+n.name})},Se=(e,t)=>{let n=l.parse(e);return l.format({dir:n.dir,ext:n.ext,name:t})},Ce=e=>l.parse(e).name,we=e=>l.basename(e),Te=e=>l.join(e.dir,e.base),Ee=e=>l.dirname(e);export{be as appendToFileName,_e as changeExtension,Se as changeFileName,ne as commandExists,y as commandExistsAsync,p as defaultEncoding,A as directoryExists,j as directoryExistsAsync,u as errorCodes,g as executeCommand,_ as executeCommandAsync,v as executeCommandAsyncWithResult,te as executeCommandString,ee as executeCommandWithResult,se as fileEmpty,oe as fileExists,ce as fileExistsAsync,Ee as getDirectory,he as getDiskUsage,ge as getDiskUsageAsync,ye as getExtension,Ce as getFileName,we as getFileNameWithExtension,le as getFileSize,ue as getFreeSpace,de as getFreeSpaceAsync,Te as getFullPath,x as getStatAsync,b as getStatSync,fe as getTotalSpace,pe as getTotalSpaceAsync,$ as getUsedSpace,me as getUsedSpaceAsync,f as isNodeError,T as makeDirectoryAsync,w as makeDirectorySync,S as pathExists,C as pathExistsAsync,xe as prependToFileName,d as putError,V as readBinaryFileAsync,B as readBinaryFileSync,D as readDirectoryAsync,re as readDirectoryNotRecursive,ie as readDirectoryNotRecursiveAsync,E as readDirectorySync,G as readImageAsync,W as readImageSync,L as readJsonAsync,I as readJsonSync,N as readTextFileAsync,M as readTextFileSync,k as removeDirectoryAsync,O as removeDirectorySync,ve as removeExtension,ae as removeFileAsync,Y as removeFileSync,U as saveBinaryFileAsync,H as saveBinaryFileSync,q as saveImageAsync,K as saveImageSync,z as saveJsonAsync,R as saveJsonSync,F as saveTextFileAsync,P as saveTextFileSync};
//# sourceMappingURL=node.mjs.map