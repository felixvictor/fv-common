{"version":3,"file":"node.mjs","names":["error: unknown","path","error: unknown","error: unknown","error: unknown","error: unknown","error: unknown"],"sources":["../src/node/error.ts","../src/node/fs/constants.ts","../src/node/command.ts","../src/node/fs/stat.ts","../src/node/fs/directory.ts","../src/node/fs/file-io.ts","../src/node/fs/file-ops.ts","../src/node/fs/fs.ts","../src/node/fs/path.ts"],"sourcesContent":["/**\n * Common Node.js error codes as constants.\n */\nexport const errorCodes = {\n    addressInUse: \"EADDRINUSE\",\n    brokenPipe: \"EPIPE\",\n    connectionRefused: \"ECONNREFUSED\",\n    directoryNotEmpty: \"ENOTEMPTY\",\n    fileExists: \"EEXIST\",\n    fileNotFound: \"ENOENT\",\n    invalidArgument: \"EINVAL\",\n    noSpaceLeft: \"ENOSPC\",\n    operationNotPermitted: \"EPERM\",\n    permissionDenied: \"EACCES\",\n    readOnlyFileSystem: \"EROFS\",\n    timeout: \"ETIMEDOUT\",\n    tooManyOpenFiles: \"EMFILE\",\n} as const\n\n/**\n * Logs an error message to console.error.\n * Extracts message from Error objects or converts to string.\n *\n * @param error - The error to log (Error object, string, or any value).\n *\n * @example\n * try {\n *   riskyOperation()\n * } catch (error) {\n *   putError(error)\n * }\n */\nexport const putError = (error: unknown): void => {\n    const message = error instanceof Error ? error.message : String(error)\n    console.error(\"Request failed -->\", message)\n}\n\n/**\n * Checks if an error is a Node.js system error with an error code.\n *\n * @param error - The error to check.\n * @returns True if error is a NodeJS.ErrnoException, false otherwise.\n *\n * @example\n * try {\n *   fs.readFileSync('missing.txt')\n * } catch (error) {\n *   if (isNodeError(error)) {\n *     console.log(`Error code: ${error.code}`)\n *   }\n * }\n */\nexport const isNodeError = (error: unknown): error is NodeJS.ErrnoException => {\n    return error instanceof Error && \"code\" in error\n}\n","export const defaultEncoding = \"utf8\" as const\n","import type { ExecSyncOptions } from \"node:child_process\"\n\nimport { execFile, execFileSync, execSync } from \"node:child_process\"\nimport { promisify } from \"node:util\"\n\nimport { isNodeError, putError } from \"./error.js\"\nimport { defaultEncoding } from \"./fs/constants\"\n\nconst execFileAsync = promisify(execFile)\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Result of async command execution.\n */\ninterface AsyncCommandResult {\n    error?: Error\n    stderr: string\n    stdout: string\n    success: boolean\n}\n\n/**\n * Result of command execution.\n */\ninterface CommandResult {\n    error?: Error\n    output: string | undefined\n    success: boolean\n}\n\n// ============================================================================\n// Helpers\n// ============================================================================\n\n/**\n * Logs error details for command execution failures.\n */\nconst logCommandError = (command: string, error: unknown): void => {\n    if (isNodeError(error)) {\n        if (error.code === \"ENOENT\") {\n            console.error(\"Command not found:\", command)\n            console.error(\"Error details:\", error.message)\n        } else {\n            console.error(\"Command execution failed:\", command)\n            console.error(\"Error code:\", error.code)\n            console.error(\"Error details:\", error.message)\n        }\n    } else {\n        putError(String(error))\n    }\n}\n\n// ============================================================================\n// Command Execution\n// ============================================================================\n\n/**\n * Executes a command synchronously through a shell with error handling.\n * Supports shell features like pipes, redirects, and variable expansion.\n *\n * @param command - The command string to execute (e.g., \"ls -la | grep node\").\n * @param options - Optional execSync options.\n * @returns Command output as string, or empty string on error.\n *\n * @example\n * const output = executeCommand(\"ls -la\")\n * console.log(output)\n *\n * @example\n * // With shell features\n * const output = executeCommand(\"echo $HOME && pwd\", { cwd: \"/tmp\" })\n */\nexport const executeCommand = (command: string, options?: ExecSyncOptions): string => {\n    try {\n        return execSync(command, { ...options, encoding: defaultEncoding })\n    } catch (error: unknown) {\n        logCommandError(command, error)\n        return \"\"\n    }\n}\n\n/**\n * Executes a command synchronously through a shell and returns a detailed result.\n *\n * @param command - The command string to execute.\n * @param options - Optional execSync options.\n * @returns Object containing success status, output, and error if any.\n *\n * @example\n * const result = executeCommandWithResult(\"ls -la\")\n * if (result.success) {\n *   console.log(result.output)\n * } else {\n *   console.error(\"Command failed:\", result.error)\n * }\n */\nexport const executeCommandWithResult = (command: string, options?: ExecSyncOptions): CommandResult => {\n    try {\n        const output = execSync(command, { ...options, encoding: defaultEncoding })\n        return {\n            output,\n            success: true,\n        }\n    } catch (error: unknown) {\n        const errorObject = error instanceof Error ? error : new Error(String(error))\n\n        // Log error details\n        if (isNodeError(error)) {\n            if (error.code === \"ENOENT\") {\n                console.error(\"Command not found:\", command)\n            } else {\n                console.error(\"Command execution failed:\", command)\n                console.error(\"Error code:\", error.code)\n            }\n        }\n\n        return {\n            error: errorObject,\n            output: undefined,\n            success: false,\n        }\n    }\n}\n\n/**\n * Executes a command synchronously and returns trimmed output as string.\n * Returns empty string on error.\n *\n * @param command - The command string to execute.\n * @param options - Optional execSync options.\n * @returns Trimmed command output as string, or empty string on error.\n *\n * @example\n * const path = executeCommandString(\"pwd\")\n * console.log(\"Current directory:\", path)\n */\nexport const executeCommandString = (command: string, options?: ExecSyncOptions): string => {\n    const output = executeCommand(command, options)\n    return output.trim()\n}\n\n/**\n * Checks if a command exists and is executable.\n * Uses 'which' on Unix-like systems, 'where' on Windows.\n *\n * @param command - Command name to check (e.g., \"git\", \"node\").\n * @returns True if command exists, false otherwise.\n *\n * @example\n * if (commandExists(\"git\")) {\n *   console.log(\"Git is available\")\n * }\n */\nexport const commandExists = (command: string): boolean => {\n    try {\n        const checkCommand = process.platform === \"win32\" ? \"where\" : \"which\"\n        execFileSync(checkCommand, [command], { stdio: \"ignore\" })\n        return true\n    } catch {\n        return false\n    }\n}\n\n// ============================================================================\n// Async Command Execution\n// ============================================================================\n\n/**\n * Executes a command asynchronously through a shell with error handling.\n * Supports shell features like pipes, redirects, and variable expansion.\n *\n * @param command - The command string to execute.\n * @param options - Optional exec options.\n * @returns Promise resolving to trimmed command stdout, or empty string on error.\n *\n * @example\n * const output = await executeCommandAsync(\"ls -la\")\n * console.log(output)\n *\n * @example\n * // With options and shell features\n * const output = await executeCommandAsync(\"pwd && echo done\", { cwd: \"/tmp\" })\n */\nexport const executeCommandAsync = async (command: string, options?: ExecSyncOptions): Promise<string> => {\n    try {\n        const { stdout } = await execFileAsync(command, { ...options, encoding: defaultEncoding, shell: true })\n        return stdout.trim()\n    } catch (error: unknown) {\n        logCommandError(command, error)\n        return \"\"\n    }\n}\n\n/**\n * Executes a command asynchronously through a shell and returns a detailed result.\n *\n * @param command - The command string to execute.\n * @param options - Optional exec options.\n * @returns Promise resolving to object containing success status, stdout, stderr, and error if any.\n *\n * @example\n * const result = await executeCommandAsyncWithResult(\"ls -la\")\n * if (result.success) {\n *   console.log(result.stdout)\n * } else {\n *   console.error(\"Command failed:\", result.error)\n *   console.error(\"stderr:\", result.stderr)\n * }\n */\nexport const executeCommandAsyncWithResult = async (\n    command: string,\n    options?: ExecSyncOptions,\n): Promise<AsyncCommandResult> => {\n    try {\n        const { stderr, stdout } = await execFileAsync(command, { ...options, encoding: defaultEncoding, shell: true })\n        return {\n            stderr: stderr.trim(),\n            stdout: stdout.trim(),\n            success: true,\n        }\n    } catch (error: unknown) {\n        const errorObject = error instanceof Error ? error : new Error(String(error))\n\n        // Extract stdout/stderr from exec error if available\n        let stdout = \"\"\n        let stderr = \"\"\n        if (\n            error &&\n            typeof error === \"object\" &&\n            \"stdout\" in error &&\n            \"stderr\" in error &&\n            typeof error.stdout === \"string\" &&\n            typeof error.stderr === \"string\"\n        ) {\n            stdout = error.stdout\n            stderr = error.stderr\n        }\n\n        // Log error details\n        if (isNodeError(error)) {\n            if (error.code === \"ENOENT\") {\n                console.error(\"Command not found:\", command)\n            } else {\n                console.error(\"Command execution failed:\", command)\n                console.error(\"Error code:\", error.code)\n            }\n        }\n\n        return {\n            error: errorObject,\n            stderr: stderr.trim(),\n            stdout: stdout.trim(),\n            success: false,\n        }\n    }\n}\n\n/**\n * Checks if a command exists asynchronously.\n * Uses 'which' on Unix-like systems, 'where' on Windows.\n *\n * @param command - Command name to check (e.g., \"git\", \"node\").\n * @returns Promise resolving to true if command exists, false otherwise.\n *\n * @example\n * if (await commandExistsAsync(\"git\")) {\n *   console.log(\"Git is available\")\n * }\n */\nexport const commandExistsAsync = async (command: string): Promise<boolean> => {\n    try {\n        const checkCommand = process.platform === \"win32\" ? \"where\" : \"which\"\n        await execFileAsync(checkCommand, [command])\n        return true\n    } catch {\n        return false\n    }\n}\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"../error.js\"\n\n// ============================================================================\n// File/Directory Statistics\n// ============================================================================\n\n/**\n * Gets file or directory statistics synchronously.\n * Returns undefined if an error occurs.\n *\n * @param path - Path to the file or directory.\n * @returns Stats object, or undefined on error.\n *\n * @example\n * const stats = getStatSync('/path/to/file.txt')\n * if (stats) {\n *   console.log(`Size: ${stats.size} bytes`)\n *   console.log(`Is file: ${stats.isFile()}`)\n * }\n */\nexport const getStatSync = (path: string): fs.Stats | undefined => {\n    try {\n        return fs.statSync(path, { throwIfNoEntry: false })\n    } catch (error: unknown) {\n        putError(error)\n        return undefined\n    }\n}\n\n/**\n * Gets file or directory statistics asynchronously.\n * Returns undefined if an error occurs.\n *\n * @param path - Path to the file or directory.\n * @returns Promise resolving to stats object, or undefined on error.\n *\n * @example\n * const stats = await getStatAsync('/path/to/file.txt')\n * if (stats) {\n *   console.log(`Size: ${stats.size} bytes`)\n *   console.log(`Is file: ${stats.isFile()}`)\n * }\n */\nexport const getStatAsync = async (path: string): Promise<fs.Stats | undefined> => {\n    try {\n        const stats = await fsPromises.stat(path)\n        return stats\n    } catch (error: unknown) {\n        putError(error)\n        return undefined\n    }\n}\n\n/**\n * Checks if a path exists (file, directory, or symlink).\n *\n * @param path - Path to check.\n * @returns True if path exists, false otherwise.\n *\n * @example\n * if (pathExists('/path/to/something')) {\n *   console.log('Path exists')\n * }\n */\nexport const pathExists = (path: string): boolean => {\n    return getStatSync(path) !== undefined\n}\n\n/**\n * Checks if a path exists (file, directory, or symlink) asynchronously.\n *\n * @param path - Path to check.\n * @returns Promise resolving to true if path exists, false otherwise.\n *\n * @example\n * if (await pathExistsAsync('/path/to/something')) {\n *   console.log('Path exists')\n * }\n */\nexport const pathExistsAsync = async (path: string): Promise<boolean> => {\n    return (await getStatAsync(path)) !== undefined\n}\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"../error.js\"\nimport { getStatSync } from \"./stat.js\"\n\n// ============================================================================\n// Directory Creation\n// ============================================================================\n\n/**\n * Creates a directory synchronously, including parent directories if needed.\n * Logs error but doesn't throw on failure.\n *\n * @param directory - Path to the directory to create.\n *\n * @example\n * makeDirectorySync(\"data/logs/2024\")\n */\nexport const makeDirectorySync = (directory: string): void => {\n    try {\n        fs.mkdirSync(directory, { recursive: true })\n    } catch (error: unknown) {\n        putError(`Cannot create directory ${directory}\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Creates a directory asynchronously, including parent directories if needed.\n * Logs error but doesn't throw on failure.\n *\n * @param directory - Path to the directory to create.\n *\n * @example\n * await makeDirectoryAsync(\"data/logs/2024\")\n */\nexport const makeDirectoryAsync = async (directory: string): Promise<void> => {\n    try {\n        await fsPromises.mkdir(directory, { recursive: true })\n    } catch (error: unknown) {\n        putError(`Cannot create directory ${directory}\\nError: ${String(error)}`)\n    }\n}\n\n// ============================================================================\n// Directory Reading\n// ============================================================================\n\n/**\n * Reads directory contents recursively, returning all files and subdirectories.\n *\n * @param directoryPath - Path to the directory to read.\n * @returns Array of relative paths to all files and directories within.\n *\n * @example\n * const allFiles = readDirectorySync(\"src\")\n * // Returns: [\"index.ts\", \"utils/helper.ts\", \"utils/config.ts\", ...]\n */\nexport const readDirectorySync = (directoryPath: string): string[] => {\n    return fs.readdirSync(directoryPath, { recursive: true }) as string[]\n}\n\n/**\n * Reads directory contents recursively, returning all files and subdirectories.\n * Async version of readDirectorySync.\n *\n * @param directoryPath - Path to the directory to read.\n * @returns Promise resolving to array of relative paths.\n *\n * @example\n * const allFiles = await readDirectoryAsync(\"src\")\n */\nexport const readDirectoryAsync = async (directoryPath: string): Promise<string[]> => {\n    return await fsPromises.readdir(directoryPath, { recursive: true })\n}\n\n/**\n * Reads immediate directory contents only (non-recursive).\n * Does not traverse subdirectories.\n *\n * @param directoryPath - Path to the directory to read.\n * @returns Array of file and directory names in the immediate directory.\n *\n * @example\n * const files = readDirectoryNotRecursive(\"src\")\n * // Returns: [\"index.ts\", \"utils\", \"components\"] (no nested paths)\n */\nexport const readDirectoryNotRecursive = (directoryPath: string): string[] => {\n    return fs.readdirSync(directoryPath, { recursive: false }) as string[]\n}\n\n/**\n * Reads immediate directory contents only (non-recursive).\n * Async version of readDirectoryNotRecursive.\n *\n * @param directoryPath - Path to the directory to read.\n * @returns Promise resolving to array of file and directory names.\n *\n * @example\n * const files = await readDirectoryNotRecursiveAsync(\"src\")\n */\nexport const readDirectoryNotRecursiveAsync = async (directoryPath: string): Promise<string[]> => {\n    return await fsPromises.readdir(directoryPath, { recursive: false })\n}\n\n// ============================================================================\n// Directory Removal\n// ============================================================================\n\n/**\n * Removes a directory and all its contents recursively.\n * Does nothing if directory doesn't exist (no error thrown).\n *\n * @param directoryPath - Path to the directory to remove.\n *\n * @example\n * removeDirectorySync(\"temp/build\")\n */\nexport const removeDirectorySync = (directoryPath: string): void => {\n    fs.rmSync(directoryPath, { force: true, recursive: true })\n}\n\n/**\n * Removes a directory and all its contents recursively.\n * Does nothing if directory doesn't exist (no error thrown).\n * Async version of removeDirectorySync.\n *\n * @param directoryPath - Path to the directory to remove.\n *\n * @example\n * await removeDirectoryAsync(\"temp/build\")\n */\nexport const removeDirectoryAsync = async (directoryPath: string): Promise<void> => {\n    await fsPromises.rm(directoryPath, { force: true, recursive: true })\n}\n\n// ============================================================================\n// Directory Existence\n// ============================================================================\n\n/**\n * Checks if a path exists and is a directory (not a file).\n *\n * @param directoryPath - Path to check.\n * @returns True if path exists and is a directory, false otherwise.\n *\n * @example\n * if (directoryExists(\"data/logs\")) {\n *   console.log(\"Logs directory exists\")\n * }\n */\nexport const directoryExists = (directoryPath: string): boolean => {\n    const stat = getStatSync(directoryPath)\n    return stat?.isDirectory() === true\n}\n\n/**\n * Checks if a path exists and is a directory (not a file).\n * Async version of directoryExists.\n *\n * @param directoryPath - Path to check.\n * @returns Promise resolving to true if path exists and is a directory, false otherwise.\n *\n * @example\n * if (await directoryExistsAsync(\"data/logs\")) {\n *   console.log(\"Logs directory exists\")\n * }\n */\nexport const directoryExistsAsync = async (directoryPath: string): Promise<boolean> => {\n    try {\n        const stats = await fsPromises.stat(directoryPath)\n        return stats.isDirectory()\n    } catch {\n        return false\n    }\n}\n","import { readFileSync, writeFile, writeFileSync } from \"atomically\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { errorCodes, isNodeError, putError } from \"../error.js\"\nimport { defaultEncoding } from \"./constants.js\"\n\n// ============================================================================\n// Text File Operations\n// ============================================================================\n\n/**\n * Reads text file synchronously using atomic read operation.\n * Returns undefined if file doesn't exist or read fails.\n *\n * @param fileName - Path to the file to read.\n * @returns File contents as string, or undefined on error.\n *\n * @example\n * const content = readTextFileSync('config.txt')\n * if (content) {\n *   console.log(content)\n * }\n */\nexport const readTextFileSync = (fileName: string): string | undefined => {\n    try {\n        return readFileSync(fileName, { encoding: defaultEncoding })\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n\n/**\n * Reads text file asynchronously.\n * Returns undefined if file doesn't exist or read fails.\n *\n * @param fileName - Path to the file to read.\n * @returns Promise resolving to file contents as string, or undefined on error.\n *\n * @example\n * const content = await readTextFileAsync('config.txt')\n * if (content) {\n *   console.log(content)\n * }\n */\nexport const readTextFileAsync = async (fileName: string): Promise<string | undefined> => {\n    try {\n        return await fsPromises.readFile(fileName, { encoding: defaultEncoding })\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n\n/**\n * Saves text to file synchronously using atomic write.\n * Atomic write ensures file is not corrupted if process crashes during write.\n * Logs error but doesn't throw on failure.\n *\n * @param fileName - Path to the file to save.\n * @param data - Text content to write.\n *\n * @example\n * saveTextFileSync('output.txt', 'Hello, world!')\n */\nexport const saveTextFileSync = (fileName: string, data: string): void => {\n    try {\n        writeFileSync(fileName, data, { encoding: defaultEncoding })\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (atomically.writeFileSync)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Saves text to file asynchronously using atomic write.\n * Atomic write ensures file is not corrupted if process crashes during write.\n * Logs error but doesn't throw on failure.\n *\n * @param fileName - Path to the file to save.\n * @param data - Text content to write.\n *\n * @example\n * await saveTextFileAsync('output.txt', 'Hello, world!')\n */\nexport const saveTextFileAsync = async (fileName: string, data: string): Promise<void> => {\n    try {\n        await writeFile(fileName, data, { encoding: defaultEncoding })\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (atomically.writeFile)\\nError: ${String(error)}`)\n    }\n}\n\n// ============================================================================\n// JSON File Operations\n// ============================================================================\n\n/**\n * Reads and parses JSON file synchronously.\n * Returns undefined if file doesn't exist or JSON is invalid.\n *\n * @param fileName - Path to the JSON file to read.\n * @returns Parsed JSON data, or undefined on error.\n *\n * @example\n * const config = readJsonSync('config.json')\n * if (config) {\n *   console.log(config)\n * }\n */\nexport const readJsonSync = (fileName: string): unknown => {\n    try {\n        const json = readTextFileSync(fileName)\n        return json === undefined ? undefined : JSON.parse(json)\n    } catch (error: unknown) {\n        putError(error)\n        return undefined\n    }\n}\n\n/**\n * Reads and parses JSON file asynchronously.\n * Returns undefined if file doesn't exist or JSON is invalid.\n *\n * @param fileName - Path to the JSON file to read.\n * @returns Promise resolving to parsed JSON data, or undefined on error.\n *\n * @example\n * const config = await readJsonAsync('config.json')\n * if (config) {\n *   console.log(config)\n * }\n */\nexport const readJsonAsync = async (fileName: string): Promise<unknown> => {\n    try {\n        const json = await readTextFileAsync(fileName)\n        return json === undefined ? undefined : JSON.parse(json)\n    } catch (error: unknown) {\n        putError(error)\n        return undefined\n    }\n}\n\n/**\n * Saves an object as JSON file synchronously.\n * Uses JSON.stringify with default formatting (no pretty-print).\n *\n * @param fileName - Path to the file to save.\n * @param data - Object to serialize as JSON.\n *\n * @example\n * saveJsonSync('config.json', { key: 'value' })\n */\nexport const saveJsonSync = (fileName: string, data: object): void => {\n    saveTextFileSync(fileName, JSON.stringify(data))\n}\n\n/**\n * Saves an object as JSON file asynchronously.\n * Uses JSON.stringify with default formatting (no pretty-print).\n *\n * @param fileName - Path to the file to save.\n * @param data - Object to serialize as JSON.\n *\n * @example\n * await saveJsonAsync('config.json', { key: 'value' })\n */\nexport const saveJsonAsync = async (fileName: string, data: object): Promise<void> => {\n    await saveTextFileAsync(fileName, JSON.stringify(data))\n}\n\n// ============================================================================\n// Binary File Operations\n// ============================================================================\n\n/**\n * Reads binary file synchronously.\n * Returns undefined if file doesn't exist or read fails.\n *\n * @param fileName - Path to the file to read.\n * @returns File contents as Buffer, or undefined on error.\n *\n * @example\n * const buffer = readBinaryFileSync('image.png')\n * if (buffer) {\n *   console.log(`File size: ${buffer.length} bytes`)\n * }\n */\nexport const readBinaryFileSync = (fileName: string): Buffer | undefined => {\n    try {\n        return readFileSync(fileName)\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n\n/**\n * Reads binary file asynchronously.\n * Returns undefined if file doesn't exist or read fails.\n *\n * @param fileName - Path to the file to read.\n * @returns Promise resolving to file contents as Buffer, or undefined on error.\n *\n * @example\n * const buffer = await readBinaryFileAsync('image.png')\n * if (buffer) {\n *   console.log(`File size: ${buffer.length} bytes`)\n * }\n */\nexport const readBinaryFileAsync = async (fileName: string): Promise<Buffer | undefined> => {\n    try {\n        return await fsPromises.readFile(fileName)\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n\n/**\n * Saves binary data to file synchronously using atomic write.\n * Accepts Buffer for binary data or string for text-based binary formats.\n *\n * @param fileName - Path to the file to save.\n * @param data - Binary data as Buffer or string.\n *\n * @example\n * saveBinaryFileSync('output.bin', buffer)\n */\nexport const saveBinaryFileSync = (fileName: string, data: Buffer | string): void => {\n    try {\n        writeFileSync(fileName, data)\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (saveBinaryFileSync)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Saves binary data to file asynchronously using atomic write.\n * Accepts Buffer for binary data or string for text-based binary formats.\n *\n * @param fileName - Path to the file to save.\n * @param data - Binary data as Buffer or string.\n *\n * @example\n * await saveBinaryFileAsync('output.bin', buffer)\n */\nexport const saveBinaryFileAsync = async (fileName: string, data: Buffer | string): Promise<void> => {\n    try {\n        await writeFile(fileName, data)\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (saveBinaryFileAsync)\\nError: ${String(error)}`)\n    }\n}\n\n// ============================================================================\n// Image File Operations\n// ============================================================================\n\n/**\n * Reads image file synchronously.\n * Type-safe wrapper around readBinaryFileSync that returns Buffer.\n *\n * @param fileName - Path to the image file to read.\n * @returns Image data as Buffer, or undefined on error.\n *\n * @example\n * const image = readImageSync('photo.jpg')\n * if (image) {\n *   console.log(`Image size: ${image.length} bytes`)\n * }\n */\nexport const readImageSync = (fileName: string): Buffer | undefined => {\n    return readBinaryFileSync(fileName)\n}\n\n/**\n * Reads image file asynchronously.\n * Type-safe wrapper around readBinaryFileAsync that returns Buffer.\n *\n * @param fileName - Path to the image file to read.\n * @returns Promise resolving to image data as Buffer, or undefined on error.\n *\n * @example\n * const image = await readImageAsync('photo.jpg')\n * if (image) {\n *   console.log(`Image size: ${image.length} bytes`)\n * }\n */\nexport const readImageAsync = async (fileName: string): Promise<Buffer | undefined> => {\n    return readBinaryFileAsync(fileName)\n}\n\n/**\n * Saves image data to file synchronously.\n * Type-safe wrapper around saveBinaryFileSync that only accepts Buffer.\n *\n * @param fileName - Path to the file to save.\n * @param data - Image data as Buffer.\n *\n * @example\n * saveImageSync('output.png', imageBuffer)\n */\nexport const saveImageSync = (fileName: string, data: Buffer): void => {\n    saveBinaryFileSync(fileName, data)\n}\n\n/**\n * Saves image data to file asynchronously.\n * Type-safe wrapper around saveBinaryFileAsync that only accepts Buffer.\n *\n * @param fileName - Path to the file to save.\n * @param data - Image data as Buffer.\n *\n * @example\n * await saveImageAsync('output.png', imageBuffer)\n */\nexport const saveImageAsync = async (fileName: string, data: Buffer): Promise<void> => {\n    await saveBinaryFileAsync(fileName, data)\n}\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"../error.js\"\nimport { getStatSync } from \"./stat.js\"\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst fileSystemOptions = {\n    force: true,\n    throwIfNoEntry: false,\n} as const\n\n// ============================================================================\n// File Removal\n// ============================================================================\n\n/**\n * Removes a file synchronously.\n * Does nothing if file doesn't exist (no error thrown).\n *\n * @param fileName - Path to the file to remove.\n *\n * @example\n * removeFileSync(\"temp.txt\")\n */\nexport const removeFileSync = (fileName: string): void => {\n    fs.rmSync(fileName, { force: fileSystemOptions.force })\n}\n\n/**\n * Removes a file asynchronously.\n * Logs error but doesn't throw on failure.\n *\n * @param fileName - Path to the file to remove.\n *\n * @example\n * await removeFileAsync(\"temp.txt\")\n */\nexport const removeFileAsync = async (fileName: string): Promise<void> => {\n    try {\n        await fsPromises.rm(fileName, { force: fileSystemOptions.force })\n    } catch (error: unknown) {\n        putError(error)\n    }\n}\n\n// ============================================================================\n// File Existence and Properties\n// ============================================================================\n\n/**\n * Checks if a path exists and is a regular file (not a directory or symlink).\n *\n * @param fileName - Path to check.\n * @returns True if path exists and is a file, false otherwise.\n *\n * @example\n * if (fileExists(\"config.json\")) {\n *   console.log(\"Config file found\")\n * }\n */\nexport const fileExists = (fileName: string): boolean => {\n    const stat = getStatSync(fileName)\n    return stat?.isFile() === true\n}\n\n/**\n * Checks if a file exists and is empty (zero bytes).\n *\n * @param fileName - Path to check.\n * @returns True if file exists and has zero bytes, false if missing or has content.\n *\n * @example\n * if (fileEmpty(\"log.txt\")) {\n *   console.log(\"Log file is empty\")\n * }\n */\nexport const fileEmpty = (fileName: string): boolean => {\n    const stat = fs.statSync(fileName, { throwIfNoEntry: fileSystemOptions.throwIfNoEntry })\n    return stat?.size === 0\n}\n\n/**\n * Checks if a path exists and is a regular file (not a directory or symlink).\n * Async version of fileExists.\n *\n * @param fileName - Path to check.\n * @returns Promise resolving to true if path exists and is a file, false otherwise.\n *\n * @example\n * if (await fileExistsAsync(\"config.json\")) {\n *   console.log(\"Config file found\")\n * }\n */\nexport const fileExistsAsync = async (fileName: string): Promise<boolean> => {\n    try {\n        const stats = await fsPromises.stat(fileName)\n        return stats.isFile()\n    } catch {\n        return false\n    }\n}\n\n/**\n * Gets the size of a file in bytes.\n *\n * @param fileName - Path to the file.\n * @returns File size in bytes, or undefined if file doesn't exist or error occurs.\n *\n * @example\n * const size = getFileSize(\"data.json\")\n * if (size !== undefined) {\n *   console.log(`File size: ${size} bytes`)\n * }\n */\nexport const getFileSize = (fileName: string): number | undefined => {\n    const stat = getStatSync(fileName)\n    return stat?.size\n}\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"../error.js\"\n\n// ============================================================================\n// File System Statistics - Internal Helpers\n// ============================================================================\n\n/**\n * Gets file system statistics for a directory synchronously.\n * Returns undefined if an error occurs.\n */\nconst getStatFsSync = (directory: string): fs.StatsFs | undefined => {\n    try {\n        return fs.statfsSync(directory)\n    } catch (error: unknown) {\n        putError(error)\n        return undefined\n    }\n}\n\n/**\n * Gets file system statistics for a directory asynchronously.\n * Returns undefined if an error occurs.\n */\nconst getStatFsAsync = async (directory: string): Promise<fs.StatsFs | undefined> => {\n    try {\n        return await fsPromises.statfs(directory)\n    } catch (error: unknown) {\n        putError(error)\n        return undefined\n    }\n}\n\n/**\n * Calculates disk space metrics from file system stats.\n * Returns undefined if stat is undefined.\n */\nconst calculateDiskMetrics = (stat: fs.StatsFs | undefined) => {\n    if (!stat) return\n\n    const total = stat.bsize * stat.blocks\n    const free = stat.bsize * stat.bavail\n    const used = stat.bsize * (stat.blocks - stat.bfree)\n    const percentUsed = total > 0 ? (used / total) * 100 : 0\n\n    return { free, percentUsed, total, used }\n}\n\n// ============================================================================\n// Disk Space Operations\n// ============================================================================\n\n/**\n * Gets the available free space in bytes for a directory's file system.\n *\n * @param directory - Path to the directory to check.\n * @returns Free space in bytes, or undefined on error.\n *\n * @example\n * const freeBytes = getFreeSpace('/home/user')\n * if (freeBytes !== undefined) {\n *   console.log(`Free space: ${(freeBytes / 1024 / 1024 / 1024).toFixed(2)} GB`)\n * }\n */\nexport const getFreeSpace = (directory: string): number | undefined => {\n    return calculateDiskMetrics(getStatFsSync(directory))?.free\n}\n\n/**\n * Gets the available free space in bytes for a directory's file system asynchronously.\n *\n * @param directory - Path to the directory to check.\n * @returns Promise resolving to free space in bytes, or undefined on error.\n *\n * @example\n * const freeBytes = await getFreeSpaceAsync('/home/user')\n * if (freeBytes !== undefined) {\n *   console.log(`Free space: ${(freeBytes / 1024 / 1024 / 1024).toFixed(2)} GB`)\n * }\n */\nexport const getFreeSpaceAsync = async (directory: string): Promise<number | undefined> => {\n    return calculateDiskMetrics(await getStatFsAsync(directory))?.free\n}\n\n/**\n * Gets the total space in bytes for a directory's file system.\n *\n * @param directory - Path to the directory to check.\n * @returns Total space in bytes, or undefined on error.\n *\n * @example\n * const totalBytes = getTotalSpace('/home/user')\n * if (totalBytes !== undefined) {\n *   console.log(`Total space: ${(totalBytes / 1024 / 1024 / 1024).toFixed(2)} GB`)\n * }\n */\nexport const getTotalSpace = (directory: string): number | undefined => {\n    return calculateDiskMetrics(getStatFsSync(directory))?.total\n}\n\n/**\n * Gets the total space in bytes for a directory's file system asynchronously.\n *\n * @param directory - Path to the directory to check.\n * @returns Promise resolving to total space in bytes, or undefined on error.\n *\n * @example\n * const totalBytes = await getTotalSpaceAsync('/home/user')\n * if (totalBytes !== undefined) {\n *   console.log(`Total space: ${(totalBytes / 1024 / 1024 / 1024).toFixed(2)} GB`)\n * }\n */\nexport const getTotalSpaceAsync = async (directory: string): Promise<number | undefined> => {\n    return calculateDiskMetrics(await getStatFsAsync(directory))?.total\n}\n\n/**\n * Gets the used space in bytes for a directory's file system.\n *\n * @param directory - Path to the directory to check.\n * @returns Used space in bytes, or undefined on error.\n *\n * @example\n * const usedBytes = getUsedSpace('/home/user')\n * if (usedBytes !== undefined) {\n *   console.log(`Used space: ${(usedBytes / 1024 / 1024 / 1024).toFixed(2)} GB`)\n * }\n */\nexport const getUsedSpace = (directory: string): number | undefined => {\n    return calculateDiskMetrics(getStatFsSync(directory))?.used\n}\n\n/**\n * Gets the used space in bytes for a directory's file system asynchronously.\n *\n * @param directory - Path to the directory to check.\n * @returns Promise resolving to used space in bytes, or undefined on error.\n *\n * @example\n * const usedBytes = await getUsedSpaceAsync('/home/user')\n * if (usedBytes !== undefined) {\n *   console.log(`Used space: ${(usedBytes / 1024 / 1024 / 1024).toFixed(2)} GB`)\n * }\n */\nexport const getUsedSpaceAsync = async (directory: string): Promise<number | undefined> => {\n    return calculateDiskMetrics(await getStatFsAsync(directory))?.used\n}\n\n/**\n * Gets disk space usage information for a directory's file system.\n *\n * @param directory - Path to the directory to check.\n * @returns Object with free, total, used space in bytes and usage percentage, or undefined on error.\n *\n * @example\n * const usage = getDiskUsage('/home/user')\n * if (usage) {\n *   console.log(`Free: ${usage.free} bytes`)\n *   console.log(`Total: ${usage.total} bytes`)\n *   console.log(`Used: ${usage.used} bytes`)\n *   console.log(`Usage: ${usage.percentUsed.toFixed(1)}%`)\n * }\n */\nexport const getDiskUsage = (\n    directory: string,\n): undefined | { free: number; percentUsed: number; total: number; used: number } => {\n    return calculateDiskMetrics(getStatFsSync(directory))\n}\n\n/**\n * Gets disk space usage information for a directory's file system asynchronously.\n *\n * @param directory - Path to the directory to check.\n * @returns Promise resolving to object with free, total, used space in bytes and usage percentage, or undefined on error.\n *\n * @example\n * const usage = await getDiskUsageAsync('/home/user')\n * if (usage) {\n *   console.log(`Free: ${usage.free} bytes`)\n *   console.log(`Total: ${usage.total} bytes`)\n *   console.log(`Used: ${usage.used} bytes`)\n *   console.log(`Usage: ${usage.percentUsed.toFixed(1)}%`)\n * }\n */\nexport const getDiskUsageAsync = async (\n    directory: string,\n): Promise<undefined | { free: number; percentUsed: number; total: number; used: number }> => {\n    return calculateDiskMetrics(await getStatFsAsync(directory))\n}\n","import path from \"node:path\"\n\n// ============================================================================\n// File Extension Operations\n// ============================================================================\n\n/**\n * Changes the file extension of a path.\n * Automatically adds leading dot if not provided.\n *\n * @param filePath - The file path to modify.\n * @param extension - New extension (with or without leading dot).\n * @returns Path with the new extension.\n *\n * @example\n * changeExtension('/path/to/file.txt', 'md')\n * // Returns: '/path/to/file.md'\n *\n * @example\n * changeExtension('/path/to/file.txt', '.json')\n * // Returns: '/path/to/file.json'\n */\nexport const changeExtension = (filePath: string, extension: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: extension.startsWith(\".\") ? extension : `.${extension}`,\n        name: parsed.name,\n    })\n}\n\n/**\n * Removes the file extension from a path.\n *\n * @param filePath - The file path to modify.\n * @returns Path without extension.\n *\n * @example\n * removeExtension('/path/to/file.txt')\n * // Returns: '/path/to/file'\n */\nexport const removeExtension = (filePath: string): string => {\n    const parsed = path.parse(filePath)\n    return path.join(parsed.dir, parsed.name)\n}\n\n/**\n * Gets the file extension from a path (including the leading dot).\n *\n * @param filePath - The file path.\n * @returns Extension with leading dot, or empty string if no extension.\n *\n * @example\n * getExtension('/path/to/file.txt')\n * // Returns: '.txt'\n *\n * @example\n * getExtension('/path/to/file')\n * // Returns: ''\n */\nexport const getExtension = (filePath: string): string => {\n    return path.extname(filePath)\n}\n\n// ============================================================================\n// File Name Operations\n// ============================================================================\n\n/**\n * Appends text to the filename (before extension).\n * Useful for creating variants like 'file-copy.txt' or 'image-thumb.jpg'.\n *\n * @param filePath - The file path to modify.\n * @param suffix - Text to append to the filename.\n * @returns Path with suffix added to filename.\n *\n * @example\n * appendToFileName('/path/to/file.txt', '-copy')\n * // Returns: '/path/to/file-copy.txt'\n *\n * @example\n * appendToFileName('/path/to/image.jpg', '-thumb')\n * // Returns: '/path/to/image-thumb.jpg'\n */\nexport const appendToFileName = (filePath: string, suffix: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: parsed.ext,\n        name: parsed.name + suffix,\n    })\n}\n\n/**\n * Prepends text to the filename (before extension).\n *\n * @param filePath - The file path to modify.\n * @param prefix - Text to prepend to the filename.\n * @returns Path with prefix added to filename.\n *\n * @example\n * prependToFileName('/path/to/file.txt', 'draft-')\n * // Returns: '/path/to/draft-file.txt'\n */\nexport const prependToFileName = (filePath: string, prefix: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: parsed.ext,\n        name: prefix + parsed.name,\n    })\n}\n\n/**\n * Replaces the filename while keeping directory and extension.\n *\n * @param filePath - The file path to modify.\n * @param newName - New filename (without extension).\n * @returns Path with new filename.\n *\n * @example\n * changeFileName('/path/to/file.txt', 'newname')\n * // Returns: '/path/to/newname.txt'\n *\n * @example\n * changeFileName('/path/to/old.json', 'config')\n * // Returns: '/path/to/config.json'\n */\nexport const changeFileName = (filePath: string, newName: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: parsed.ext,\n        name: newName,\n    })\n}\n\n/**\n * Gets the filename without extension.\n *\n * @param filePath - The file path.\n * @returns Filename without extension.\n *\n * @example\n * getFileName('/path/to/file.txt')\n * // Returns: 'file'\n */\nexport const getFileName = (filePath: string): string => {\n    return path.parse(filePath).name\n}\n\n/**\n * Gets the filename with extension (base name).\n *\n * @param filePath - The file path.\n * @returns Filename with extension.\n *\n * @example\n * getFileNameWithExtension('/path/to/file.txt')\n * // Returns: 'file.txt'\n */\nexport const getFileNameWithExtension = (filePath: string): string => {\n    return path.basename(filePath)\n}\n\n// ============================================================================\n// Path Operations\n// ============================================================================\n\n/**\n * Reconstructs a full path from a parsed path object.\n * This is a convenience wrapper around path.join for parsed paths.\n *\n * @param parsedPath - Parsed path object from path.parse().\n * @returns Full file path.\n *\n * @example\n * const parsed = path.parse('/path/to/file.txt')\n * getFullPath(parsed)\n * // Returns: '/path/to/file.txt'\n */\nexport const getFullPath = (parsedPath: path.ParsedPath): string => {\n    return path.join(parsedPath.dir, parsedPath.base)\n}\n\n/**\n * Gets the directory path from a file path.\n *\n * @param filePath - The file path.\n * @returns Directory path.\n *\n * @example\n * getDirectory('/path/to/file.txt')\n * // Returns: '/path/to'\n */\nexport const getDirectory = (filePath: string): string => {\n    return path.dirname(filePath)\n}\n\nexport const joinPaths = (path1: string, path2: string): string => path.join(path1, path2)\n"],"mappings":"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"}