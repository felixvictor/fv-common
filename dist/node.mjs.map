{"version":3,"file":"node.mjs","names":["error: unknown","error: unknown","error: unknown"],"sources":["../src/fs/error.ts","../src/fs/directory.ts","../src/fs/file-io.ts","../src/fs/file-ops.ts","../src/fs/path.ts"],"sourcesContent":["const errorCodes = {\n    fileNotFound: \"ENOENT\",\n} as const\n\nexport const putError = (error: unknown): void => {\n    const message = error instanceof Error ? error.message : String(error)\n    console.error(\"Request failed -->\", message)\n}\n\nexport const isNodeError = (error: unknown): error is NodeJS.ErrnoException => error instanceof Error && \"code\" in error\n\nexport { errorCodes }\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"./error.js\"\n\nexport const makeDirectorySync = (directory: string): void => {\n    try {\n        fs.mkdirSync(directory, { recursive: true })\n    } catch (error: unknown) {\n        putError(`Cannot make directory ${directory}\\nError: ${String(error)}`)\n    }\n}\n\nexport const makeDirectoryAsync = async (directory: string): Promise<void> => {\n    try {\n        await fsPromises.mkdir(directory, { recursive: true })\n    } catch (error: unknown) {\n        putError(`Cannot make directory ${directory}\\nError: ${String(error)}`)\n    }\n}\n\nexport const readDirectorySync = (directoryPath: string): string[] => {\n    return fs.readdirSync(directoryPath, { recursive: true }) as string[]\n}\n\nexport const removeDirectorySync = (directoryPath: string): void => {\n    fs.rmSync(directoryPath, { force: true, recursive: true })\n}\n","import { readFileSync, writeFile, writeFileSync } from \"atomically\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { errorCodes, isNodeError, putError } from \"./error.js\"\n\nconst encoding = \"utf8\" as const\n\n/**\n * Saves text to file asynchronously using atomic write.\n * Atomic write ensures file is not corrupted if process crashes during write.\n * Logs error but doesn't throw on failure.\n */\nexport const saveTextFileAsync = async (fileName: string, data: string): Promise<void> => {\n    try {\n        await writeFile(fileName, data, { encoding })\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (atomically.writeFile)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Synchronous version of saveTextFileAsync.\n * Uses atomic write to prevent file corruption.\n */\nexport const saveTextFileSync = (fileName: string, data: string): void => {\n    try {\n        writeFileSync(fileName, data, { encoding })\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (atomically.writeFileSync)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Saves an object as JSON file asynchronously.\n * Uses JSON.stringify with default formatting (no pretty-print).\n */\nexport const saveJsonAsync = async (fileName: string, data: object): Promise<void> => {\n    await saveTextFileAsync(fileName, JSON.stringify(data))\n}\n\n/**\n * Synchronous version of saveJsonAsync.\n * Converts object to JSON string and saves atomically.\n */\nexport const saveJson = (fileName: string, data: object): void => {\n    saveTextFileSync(fileName, JSON.stringify(data))\n}\n\n/**\n * Saves binary data to file synchronously using atomic write.\n * Accepts Buffer for binary data or string for text-based binary formats.\n */\nexport const saveBinaryFile = (fileName: string, data: Buffer | string): void => {\n    try {\n        writeFileSync(fileName, data)\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (saveBinaryFile)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Saves image data to file.\n * Type-safe wrapper around saveBinaryFile that only accepts Buffer.\n */\nexport const saveImage = (fileName: string, data: Buffer): void => {\n    saveBinaryFile(fileName, data)\n}\n\n// --- File Reading ---\n\n/**\n * Reads text file synchronously using atomic read operation.\n * Returns undefined if file doesn't exist or read fails.\n * Logs specific error message for missing files.\n */\nexport const readTextFileSync = (fileName: string): string | undefined => {\n    try {\n        return readFileSync(fileName, { encoding })\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n\n/**\n * Reads and parses JSON file synchronously.\n * Returns undefined if file doesn't exist or JSON is invalid.\n * Logs errors but doesn't throw.\n */\nexport const readJsonSync = (fileName: string): unknown => {\n    try {\n        const json = readTextFileSync(fileName)\n        return json === undefined ? undefined : JSON.parse(json)\n    } catch (error: unknown) {\n        putError(error)\n        return undefined\n    }\n}\n\n/**\n * Async version of readTextFileSync.\n * Reads text file and returns undefined on failure.\n */\nexport const readTextFileAsync = async (fileName: string): Promise<string | undefined> => {\n    try {\n        return await fsPromises.readFile(fileName, { encoding })\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"./error.js\"\n\nconst fileSystemOptions = {\n    force: true,\n    throwIfNoEntry: false,\n} as const\n\n/**\n * Removes a file. Does nothing if file doesn't exist (force: true).\n */\nexport const removeFileSync = (fileName: string): void => {\n    fs.rmSync(fileName, { force: fileSystemOptions.force })\n}\n\n/**\n * Async version of removeFileSync.\n * Logs error but doesn't throw on failure.\n */\nexport const removeFileAsync = async (fileName: string): Promise<void> => {\n    try {\n        await fsPromises.rm(fileName, { force: fileSystemOptions.force })\n    } catch (error: unknown) {\n        putError(error)\n    }\n}\n\n// --- File Existence and Stats ---\n\n/**\n * Checks if a file exists and is a regular file (not a directory).\n * @returns true if file exists, false otherwise\n */\nexport const fileExists = (fileName: string): boolean => {\n    try {\n        const stat = fs.statSync(fileName)\n        return stat.isFile()\n    } catch {\n        return false\n    }\n}\n\n/**\n * Checks if a file exists and has zero bytes.\n * @returns true if file exists and is empty, false if missing or has content\n */\nexport const fileEmpty = (fileName: string): boolean => {\n    const stat = fs.statSync(fileName, { throwIfNoEntry: fileSystemOptions.throwIfNoEntry })\n    return stat?.size === 0\n}\n\n/**\n * Async version of fileExists.\n * Checks if path exists and is a regular file.\n */\nexport const fileExistsAsync = async (fileName: string): Promise<boolean> => {\n    try {\n        const stats = await fsPromises.stat(fileName)\n        return stats.isFile()\n    } catch {\n        return false\n    }\n}\n","import path from \"node:path\"\n\n/**\n * Changes the file extension of a path.\n * Automatically adds leading dot if not provided.\n * @example changeExtension('/path/to/file.txt', 'md') → '/path/to/file.md'\n * @example changeExtension('/path/to/file.txt', '.json') → '/path/to/file.json'\n */\nexport const changeExtension = (filePath: string, extension: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: extension.startsWith(\".\") ? extension : `.${extension}`,\n        name: parsed.name,\n    })\n}\n\n/**\n * Appends text to the filename (before extension).\n * Useful for creating variants like 'file-copy.txt' or 'image-thumb.jpg'.\n * @example appendToFileName('/path/to/file.txt', '-copy') → '/path/to/file-copy.txt'\n */\nexport const appendToFileName = (filePath: string, suffix: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: parsed.ext,\n        name: parsed.name + suffix,\n    })\n}\n\n/**\n * Replaces the filename while keeping directory and extension.\n * @example changeFileName('/path/to/file.txt', 'newname') → '/path/to/newname.txt'\n */\nexport const changeFileName = (filePath: string, newName: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: parsed.ext,\n        name: newName,\n    })\n}\n"],"mappings":"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"}