{"version":3,"file":"node.mjs","names":["error: unknown","error: unknown","error: unknown"],"sources":["../src/fs/error.ts","../src/fs/directory.ts","../src/fs/file-io.ts","../src/fs/file-ops.ts","../src/fs/path.ts"],"sourcesContent":["const errorCodes = {\n    fileNotFound: \"ENOENT\",\n} as const\n\nexport const putError = (error: unknown): void => {\n    const message = error instanceof Error ? error.message : String(error)\n    console.error(\"Request failed -->\", message)\n}\n\nexport const isNodeError = (error: unknown): error is NodeJS.ErrnoException => error instanceof Error && \"code\" in error\n\nexport { errorCodes }\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"./error.js\"\n\nexport const makeDirectorySync = (directory: string): void => {\n    try {\n        fs.mkdirSync(directory, { recursive: true })\n    } catch (error: unknown) {\n        putError(`Cannot make directory ${directory}\\nError: ${String(error)}`)\n    }\n}\n\nexport const makeDirectoryAsync = async (directory: string): Promise<void> => {\n    try {\n        await fsPromises.mkdir(directory, { recursive: true })\n    } catch (error: unknown) {\n        putError(`Cannot make directory ${directory}\\nError: ${String(error)}`)\n    }\n}\n\nexport const readDirectorySync = (directoryPath: string): string[] => {\n    return fs.readdirSync(directoryPath, { recursive: true }) as string[]\n}\n\nexport const removeDirectorySync = (directoryPath: string): void => {\n    fs.rmSync(directoryPath, { force: true, recursive: true })\n}\n","import { readFileSync, writeFile, writeFileSync } from \"atomically\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { errorCodes, isNodeError, putError } from \"./error.js\"\n\nconst encoding = \"utf8\" as const\n\n/**\n * Saves text to file asynchronously using atomic write.\n * Atomic write ensures file is not corrupted if process crashes during write.\n * Logs error but doesn't throw on failure.\n */\nexport const saveTextFileAsync = async (fileName: string, data: string): Promise<void> => {\n    try {\n        await writeFile(fileName, data, { encoding })\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (atomically.writeFile)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Synchronous version of saveTextFileAsync.\n * Uses atomic write to prevent file corruption.\n */\nexport const saveTextFileSync = (fileName: string, data: string): void => {\n    try {\n        writeFileSync(fileName, data, { encoding })\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (atomically.writeFileSync)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Saves an object as JSON file asynchronously.\n * Uses JSON.stringify with default formatting (no pretty-print).\n */\nexport const saveJsonAsync = async (fileName: string, data: object): Promise<void> => {\n    await saveTextFileAsync(fileName, JSON.stringify(data))\n}\n\n/**\n * Synchronous version of saveJsonAsync.\n * Converts object to JSON string and saves atomically.\n */\nexport const saveJson = (fileName: string, data: object): void => {\n    saveTextFileSync(fileName, JSON.stringify(data))\n}\n\n/**\n * Saves binary data to file synchronously using atomic write.\n * Accepts Buffer for binary data or string for text-based binary formats.\n */\nexport const saveBinaryFile = (fileName: string, data: Buffer | string): void => {\n    try {\n        writeFileSync(fileName, data)\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (saveBinaryFile)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Saves image data to file.\n * Type-safe wrapper around saveBinaryFile that only accepts Buffer.\n */\nexport const saveImage = (fileName: string, data: Buffer): void => {\n    saveBinaryFile(fileName, data)\n}\n\n// --- File Reading ---\n\n/**\n * Reads text file synchronously using atomic read operation.\n * Returns undefined if file doesn't exist or read fails.\n * Logs specific error message for missing files.\n */\nexport const readTextFileSync = (fileName: string): string | undefined => {\n    try {\n        return readFileSync(fileName, { encoding })\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n\n/**\n * Reads and parses JSON file synchronously.\n * Returns undefined if file doesn't exist or JSON is invalid.\n * Logs errors but doesn't throw.\n */\nexport const readJsonSync = (fileName: string): unknown => {\n    try {\n        const json = readTextFileSync(fileName)\n        return json === undefined ? undefined : JSON.parse(json)\n    } catch (error: unknown) {\n        putError(error)\n        return undefined\n    }\n}\n\n/**\n * Async version of readTextFileSync.\n * Reads text file and returns undefined on failure.\n */\nexport const readTextFileAsync = async (fileName: string): Promise<string | undefined> => {\n    try {\n        return await fsPromises.readFile(fileName, { encoding })\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"./error.js\"\n\nconst fileSystemOptions = {\n    force: true,\n    throwIfNoEntry: false,\n} as const\n\n/**\n * Removes a file. Does nothing if file doesn't exist (force: true).\n */\nexport const removeFileSync = (fileName: string): void => {\n    fs.rmSync(fileName, { force: fileSystemOptions.force })\n}\n\n/**\n * Async version of removeFileSync.\n * Logs error but doesn't throw on failure.\n */\nexport const removeFileAsync = async (fileName: string): Promise<void> => {\n    try {\n        await fsPromises.rm(fileName, { force: fileSystemOptions.force })\n    } catch (error: unknown) {\n        putError(error)\n    }\n}\n\n// --- File Existence and Stats ---\n\n/**\n * Checks if a file exists and is a regular file (not a directory).\n * @returns true if file exists, false otherwise\n */\nexport const fileExists = (fileName: string): boolean => {\n    try {\n        const stat = fs.statSync(fileName)\n        return stat.isFile()\n    } catch {\n        return false\n    }\n}\n\n/**\n * Checks if a file exists and has zero bytes.\n * @returns true if file exists and is empty, false if missing or has content\n */\nexport const fileEmpty = (fileName: string): boolean => {\n    const stat = fs.statSync(fileName, { throwIfNoEntry: fileSystemOptions.throwIfNoEntry })\n    return stat?.size === 0\n}\n\n/**\n * Async version of fileExists.\n * Checks if path exists and is a regular file.\n */\nexport const fileExistsAsync = async (fileName: string): Promise<boolean> => {\n    try {\n        const stats = await fsPromises.stat(fileName)\n        return stats.isFile()\n    } catch {\n        return false\n    }\n}\n","import path from \"node:path\"\n\n/**\n * Changes the file extension of a path.\n * Automatically adds leading dot if not provided.\n * @example changeExtension('/path/to/file.txt', 'md') → '/path/to/file.md'\n * @example changeExtension('/path/to/file.txt', '.json') → '/path/to/file.json'\n */\nexport const changeExtension = (filePath: string, extension: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: extension.startsWith(\".\") ? extension : `.${extension}`,\n        name: parsed.name,\n    })\n}\n\n/**\n * Appends text to the filename (before extension).\n * Useful for creating variants like 'file-copy.txt' or 'image-thumb.jpg'.\n * @example appendToFileName('/path/to/file.txt', '-copy') → '/path/to/file-copy.txt'\n */\nexport const appendToFileName = (filePath: string, suffix: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: parsed.ext,\n        name: parsed.name + suffix,\n    })\n}\n\n/**\n * Replaces the filename while keeping directory and extension.\n * @example changeFileName('/path/to/file.txt', 'newname') → '/path/to/newname.txt'\n */\nexport const changeFileName = (filePath: string, newName: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: parsed.ext,\n        name: newName,\n    })\n}\n"],"mappings":"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"}