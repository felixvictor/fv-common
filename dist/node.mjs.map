{"version":3,"file":"node.mjs","names":["error: unknown","error: unknown","error: unknown","error: unknown"],"sources":["../src/fs/error.ts","../src/fs/command.ts","../src/fs/directory.ts","../src/fs/file-io.ts","../src/fs/file-ops.ts","../src/fs/path.ts"],"sourcesContent":["const errorCodes = {\n    fileNotFound: \"ENOENT\",\n} as const\n\nexport const putError = (error: unknown): void => {\n    const message = error instanceof Error ? error.message : String(error)\n    console.error(\"Request failed -->\", message)\n}\n\nexport const isNodeError = (error: unknown): error is NodeJS.ErrnoException => error instanceof Error && \"code\" in error\n\nexport { errorCodes }\n","import type { ExecOptions, ExecSyncOptions } from \"node:child_process\"\n\nimport { exec, execSync } from \"node:child_process\"\nimport { promisify } from \"node:util\"\n\nimport { isNodeError, putError } from \"./error.js\"\n\nconst execAsync = promisify(exec)\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Result of async command execution.\n */\ninterface AsyncCommandResult {\n    error?: Error\n    stderr: string\n    stdout: string\n    success: boolean\n}\n\n/**\n * Result of command execution.\n */\ninterface CommandResult {\n    error?: Error\n    output: Buffer | undefined\n    success: boolean\n}\n\n// ============================================================================\n// Command Execution\n// ============================================================================\n\n/**\n * Executes a shell command synchronously with error handling.\n *\n * @param command - The shell command to execute.\n * @param options - Optional execSync options.\n * @returns Buffer containing command output, or empty Buffer on error.\n *\n * @example\n * const output = executeCommand(\"ls -la\")\n * console.log(output.toString())\n *\n * @example\n * // With options\n * const output = executeCommand(\"pwd\", { cwd: \"/tmp\" })\n */\nexport const executeCommand = (command: string, options?: ExecSyncOptions): Buffer => {\n    try {\n        return execSync(command, options)\n    } catch (error: unknown) {\n        // Handle specific error cases\n        if (isNodeError(error)) {\n            if (error.code === \"ENOENT\") {\n                console.error(\"Command not found:\", command)\n                console.error(\"Error details:\", error.message)\n            } else {\n                console.error(\"Command execution failed:\", command)\n                console.error(\"Error code:\", error.code)\n                console.error(\"Error details:\", error.message)\n            }\n        } else {\n            putError(String(error))\n        }\n\n        // Return empty Buffer instead of uninitialized object\n        return Buffer.from(\"\")\n    }\n}\n\n/**\n * Executes a shell command synchronously and returns a detailed result.\n *\n * @param command - The shell command to execute.\n * @param options - Optional execSync options.\n * @returns Object containing success status, output, and error if any.\n *\n * @example\n * const result = executeCommandWithResult(\"ls -la\")\n * if (result.success) {\n *   console.log(result.output?.toString())\n * } else {\n *   console.error(\"Command failed:\", result.error)\n * }\n */\nexport const executeCommandWithResult = (command: string, options?: ExecSyncOptions): CommandResult => {\n    try {\n        const output = execSync(command, options)\n        return {\n            output,\n            success: true,\n        }\n    } catch (error: unknown) {\n        const errorObject = error instanceof Error ? error : new Error(String(error))\n\n        // Log error details\n        if (isNodeError(error)) {\n            if (error.code === \"ENOENT\") {\n                console.error(\"Command not found:\", command)\n            } else {\n                console.error(\"Command execution failed:\", command)\n                console.error(\"Error code:\", error.code)\n            }\n        }\n\n        return {\n            error: errorObject,\n            output: undefined,\n            success: false,\n        }\n    }\n}\n\n/**\n * Executes a shell command synchronously and returns output as string.\n * Returns empty string on error.\n *\n * @param command - The shell command to execute.\n * @param options - Optional execSync options.\n * @returns Command output as string, or empty string on error.\n *\n * @example\n * const path = executeCommandString(\"pwd\")\n * console.log(\"Current directory:\", path.trim())\n */\nexport const executeCommandString = (command: string, options?: ExecSyncOptions): string => {\n    const output = executeCommand(command, options)\n    return output.toString().trim()\n}\n\n/**\n * Checks if a command exists and is executable.\n *\n * @param command - Command name to check (e.g., \"git\", \"node\").\n * @returns True if command exists, false otherwise.\n *\n * @example\n * if (commandExists(\"git\")) {\n *   console.log(\"Git is available\")\n * }\n */\nexport const commandExists = (command: string): boolean => {\n    try {\n        // Use 'which' on Unix-like systems, 'where' on Windows\n        const checkCommand = process.platform === \"win32\" ? \"where\" : \"which\"\n        execSync(`${checkCommand} ${command}`, { stdio: \"ignore\" })\n        return true\n    } catch {\n        return false\n    }\n}\n\n// ============================================================================\n// Async Command Execution\n// ============================================================================\n\n/**\n * Executes a shell command asynchronously with error handling.\n *\n * @param command - The shell command to execute.\n * @param options - Optional exec options.\n * @returns Promise resolving to command stdout, or empty string on error.\n *\n * @example\n * const output = await executeCommandAsync(\"ls -la\")\n * console.log(output)\n *\n * @example\n * // With options\n * const output = await executeCommandAsync(\"pwd\", { cwd: \"/tmp\" })\n */\nexport const executeCommandAsync = async (command: string, options?: ExecOptions): Promise<string> => {\n    try {\n        const { stdout } = await execAsync(command, options)\n        return stdout.trim()\n    } catch (error: unknown) {\n        // Handle specific error cases\n        if (isNodeError(error)) {\n            if (error.code === \"ENOENT\") {\n                console.error(\"Command not found:\", command)\n                console.error(\"Error details:\", error.message)\n            } else {\n                console.error(\"Command execution failed:\", command)\n                console.error(\"Error code:\", error.code)\n                console.error(\"Error details:\", error.message)\n            }\n        } else {\n            putError(String(error))\n        }\n\n        // Return empty string on error\n        return \"\"\n    }\n}\n\n/**\n * Executes a shell command asynchronously and returns a detailed result.\n *\n * @param command - The shell command to execute.\n * @param options - Optional exec options.\n * @returns Promise resolving to object containing success status, stdout, stderr, and error if any.\n *\n * @example\n * const result = await executeCommandAsyncWithResult(\"ls -la\")\n * if (result.success) {\n *   console.log(result.stdout)\n * } else {\n *   console.error(\"Command failed:\", result.error)\n *   console.error(\"stderr:\", result.stderr)\n * }\n */\nexport const executeCommandAsyncWithResult = async (\n    command: string,\n    options?: ExecOptions,\n): Promise<AsyncCommandResult> => {\n    try {\n        const { stderr, stdout } = await execAsync(command, options)\n        return {\n            stderr: stderr.trim(),\n            stdout: stdout.trim(),\n            success: true,\n        }\n    } catch (error: unknown) {\n        const errorObject = error instanceof Error ? error : new Error(String(error))\n\n        // Extract stdout/stderr from exec error if available\n        let stdout = \"\"\n        let stderr = \"\"\n        if (error && typeof error === \"object\" && \"stdout\" in error && \"stderr\" in error) {\n            stdout = String(error.stdout || \"\")\n            stderr = String(error.stderr || \"\")\n        }\n\n        // Log error details\n        if (isNodeError(error)) {\n            if (error.code === \"ENOENT\") {\n                console.error(\"Command not found:\", command)\n            } else {\n                console.error(\"Command execution failed:\", command)\n                console.error(\"Error code:\", error.code)\n            }\n        }\n\n        return {\n            error: errorObject,\n            stderr: stderr.trim(),\n            stdout: stdout.trim(),\n            success: false,\n        }\n    }\n}\n\n/**\n * Checks if a command exists asynchronously.\n *\n * @param command - Command name to check (e.g., \"git\", \"node\").\n * @returns Promise resolving to true if command exists, false otherwise.\n *\n * @example\n * if (await commandExistsAsync(\"git\")) {\n *   console.log(\"Git is available\")\n * }\n */\nexport const commandExistsAsync = async (command: string): Promise<boolean> => {\n    try {\n        // Use 'which' on Unix-like systems, 'where' on Windows\n        const checkCommand = process.platform === \"win32\" ? \"where\" : \"which\"\n        await execAsync(`${checkCommand} ${command}`, { stdio: \"ignore\" })\n        return true\n    } catch {\n        return false\n    }\n}\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"./error.js\"\n\nexport const makeDirectorySync = (directory: string): void => {\n    try {\n        fs.mkdirSync(directory, { recursive: true })\n    } catch (error: unknown) {\n        putError(`Cannot make directory ${directory}\\nError: ${String(error)}`)\n    }\n}\n\nexport const makeDirectoryAsync = async (directory: string): Promise<void> => {\n    try {\n        await fsPromises.mkdir(directory, { recursive: true })\n    } catch (error: unknown) {\n        putError(`Cannot make directory ${directory}\\nError: ${String(error)}`)\n    }\n}\n\nexport const readDirectorySync = (directoryPath: string): string[] => {\n    return fs.readdirSync(directoryPath, { recursive: true }) as string[]\n}\n\nexport const removeDirectorySync = (directoryPath: string): void => {\n    fs.rmSync(directoryPath, { force: true, recursive: true })\n}\n","import { readFileSync, writeFile, writeFileSync } from \"atomically\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { errorCodes, isNodeError, putError } from \"./error.js\"\n\nconst encoding = \"utf8\" as const\n\n/**\n * Saves text to file asynchronously using atomic write.\n * Atomic write ensures file is not corrupted if process crashes during write.\n * Logs error but doesn't throw on failure.\n */\nexport const saveTextFileAsync = async (fileName: string, data: string): Promise<void> => {\n    try {\n        await writeFile(fileName, data, { encoding })\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (atomically.writeFile)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Synchronous version of saveTextFileAsync.\n * Uses atomic write to prevent file corruption.\n */\nexport const saveTextFileSync = (fileName: string, data: string): void => {\n    try {\n        writeFileSync(fileName, data, { encoding })\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (atomically.writeFileSync)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Saves an object as JSON file asynchronously.\n * Uses JSON.stringify with default formatting (no pretty-print).\n */\nexport const saveJsonAsync = async (fileName: string, data: object): Promise<void> => {\n    await saveTextFileAsync(fileName, JSON.stringify(data))\n}\n\n/**\n * Synchronous version of saveJsonAsync.\n * Converts object to JSON string and saves atomically.\n */\nexport const saveJson = (fileName: string, data: object): void => {\n    saveTextFileSync(fileName, JSON.stringify(data))\n}\n\n/**\n * Saves binary data to file synchronously using atomic write.\n * Accepts Buffer for binary data or string for text-based binary formats.\n */\nexport const saveBinaryFile = (fileName: string, data: Buffer | string): void => {\n    try {\n        writeFileSync(fileName, data)\n    } catch (error: unknown) {\n        putError(`Cannot save ${fileName} (saveBinaryFile)\\nError: ${String(error)}`)\n    }\n}\n\n/**\n * Saves image data to file.\n * Type-safe wrapper around saveBinaryFile that only accepts Buffer.\n */\nexport const saveImage = (fileName: string, data: Buffer): void => {\n    saveBinaryFile(fileName, data)\n}\n\n// --- File Reading ---\n\n/**\n * Reads text file synchronously using atomic read operation.\n * Returns undefined if file doesn't exist or read fails.\n * Logs specific error message for missing files.\n */\nexport const readTextFileSync = (fileName: string): string | undefined => {\n    try {\n        return readFileSync(fileName, { encoding })\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n\n/**\n * Reads and parses JSON file synchronously.\n * Returns undefined if file doesn't exist or JSON is invalid.\n * Logs errors but doesn't throw.\n */\nexport const readJsonSync = (fileName: string): unknown => {\n    try {\n        const json = readTextFileSync(fileName)\n        return json === undefined ? undefined : JSON.parse(json)\n    } catch (error: unknown) {\n        putError(error)\n        return undefined\n    }\n}\n\n/**\n * Async version of readTextFileSync.\n * Reads text file and returns undefined on failure.\n */\nexport const readTextFileAsync = async (fileName: string): Promise<string | undefined> => {\n    try {\n        return await fsPromises.readFile(fileName, { encoding })\n    } catch (error: unknown) {\n        if (isNodeError(error) && error.code === errorCodes.fileNotFound) {\n            putError(`File ${fileName} not found`)\n        } else {\n            putError(error)\n        }\n        return undefined\n    }\n}\n","import fs from \"node:fs\"\nimport fsPromises from \"node:fs/promises\"\n\nimport { putError } from \"./error.js\"\n\nconst fileSystemOptions = {\n    force: true,\n    throwIfNoEntry: false,\n} as const\n\n/**\n * Removes a file. Does nothing if file doesn't exist (force: true).\n */\nexport const removeFileSync = (fileName: string): void => {\n    fs.rmSync(fileName, { force: fileSystemOptions.force })\n}\n\n/**\n * Async version of removeFileSync.\n * Logs error but doesn't throw on failure.\n */\nexport const removeFileAsync = async (fileName: string): Promise<void> => {\n    try {\n        await fsPromises.rm(fileName, { force: fileSystemOptions.force })\n    } catch (error: unknown) {\n        putError(error)\n    }\n}\n\n// --- File Existence and Stats ---\n\n/**\n * Checks if a file exists and is a regular file (not a directory).\n * @returns true if file exists, false otherwise\n */\nexport const fileExists = (fileName: string): boolean => {\n    try {\n        const stat = fs.statSync(fileName)\n        return stat.isFile()\n    } catch {\n        return false\n    }\n}\n\n/**\n * Checks if a file exists and has zero bytes.\n * @returns true if file exists and is empty, false if missing or has content\n */\nexport const fileEmpty = (fileName: string): boolean => {\n    const stat = fs.statSync(fileName, { throwIfNoEntry: fileSystemOptions.throwIfNoEntry })\n    return stat?.size === 0\n}\n\n/**\n * Async version of fileExists.\n * Checks if path exists and is a regular file.\n */\nexport const fileExistsAsync = async (fileName: string): Promise<boolean> => {\n    try {\n        const stats = await fsPromises.stat(fileName)\n        return stats.isFile()\n    } catch {\n        return false\n    }\n}\n","import path from \"node:path\"\n\n/**\n * Changes the file extension of a path.\n * Automatically adds leading dot if not provided.\n * @example changeExtension('/path/to/file.txt', 'md') → '/path/to/file.md'\n * @example changeExtension('/path/to/file.txt', '.json') → '/path/to/file.json'\n */\nexport const changeExtension = (filePath: string, extension: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: extension.startsWith(\".\") ? extension : `.${extension}`,\n        name: parsed.name,\n    })\n}\n\n/**\n * Appends text to the filename (before extension).\n * Useful for creating variants like 'file-copy.txt' or 'image-thumb.jpg'.\n * @example appendToFileName('/path/to/file.txt', '-copy') → '/path/to/file-copy.txt'\n */\nexport const appendToFileName = (filePath: string, suffix: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: parsed.ext,\n        name: parsed.name + suffix,\n    })\n}\n\n/**\n * Replaces the filename while keeping directory and extension.\n * @example changeFileName('/path/to/file.txt', 'newname') → '/path/to/newname.txt'\n */\nexport const changeFileName = (filePath: string, newName: string): string => {\n    const parsed = path.parse(filePath)\n    return path.format({\n        dir: parsed.dir,\n        ext: parsed.ext,\n        name: newName,\n    })\n}\n"],"mappings":"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"}