import { writeFile } from "atomically"
import path from "node:path"
import { fileURLToPath } from "node:url"
import { Project, SourceFile, SyntaxKind } from "ts-morph"

const sourceDirectory = fileURLToPath(new URL("../src", import.meta.url))
const targetFile = path.resolve(sourceDirectory, "index.ts")

const isDryRun = process.argv.includes("--dry-run")

const header = `//
// Auto-generated by scripts/generate-barrel.ts
// Do not edit this file directly
//
`

const isRuntimeValueKind = (kind: SyntaxKind): boolean => {
    switch (kind) {
        case SyntaxKind.ClassDeclaration:
        case SyntaxKind.EnumDeclaration:
        case SyntaxKind.FunctionDeclaration:
        case SyntaxKind.ModuleDeclaration:
        case SyntaxKind.VariableDeclaration: {
            return true
        }
        case SyntaxKind.InterfaceDeclaration:
        case SyntaxKind.TypeAliasDeclaration: {
            return false
        }
        default: {
            return true
        }
    }
}

const normalizeRelativePath = (filePath: string): string => {
    const relative = path.relative(sourceDirectory, filePath).replaceAll("\\", "/")
    return `./${relative.replace(/\.ts$/, ".js")}`
}

const analyzeFileExports = (file: SourceFile) => {
    const values: string[] = []
    const types: string[] = []

    for (const symbol of file.getExportSymbols()) {
        const name = symbol.getName()
        if (name === "default") continue

        const declarations = symbol.getDeclarations()
        if (declarations.length === 0) continue

        const decl = declarations[0]

        const kind = decl.getKind()
        if (isRuntimeValueKind(kind)) values.push(name)
        else types.push(name)
    }

    return { types, values }
}

const generateExportStatements = (file: SourceFile): string => {
    const { types, values } = analyzeFileExports(file)
    if (values.length === 0 && types.length === 0) return ""

    const relativePath = normalizeRelativePath(file.getFilePath())
    let out = ""

    if (values.length > 0) out += `export { ${values.toSorted().join(", ")} } from '${relativePath}';\n`
    if (types.length > 0) {
        out += `export type { ${types.toSorted().join(", ")} } from '${relativePath}';\n`
    }

    return out
}

try {
    const project = new Project({ tsConfigFilePath: "./tsconfig.json" })

    const sourceFiles = project
        .getSourceFiles("src/**/*.ts")
        .filter((f) => !f.getFilePath().endsWith(".d.ts"))
        .filter((f) => f.getFilePath() !== targetFile)
        .filter((f) => !f.getBaseName().startsWith("index."))
        .toSorted((a, b) => a.getFilePath().localeCompare(b.getFilePath()))

    let body = ""
    for (const file of sourceFiles) body += generateExportStatements(file)

    const finalContent = `${header + body}\n`

    if (isDryRun) {
        process.stdout.write(finalContent)
    } else {
        await writeFile(targetFile, finalContent)
        console.log(`Generated barrel: index.ts (${sourceFiles.length} files)`)
    }
} catch (error: unknown) {
    throw new Error(`Barrel generation failure: ${error as string}`)
}
