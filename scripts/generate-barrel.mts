import { writeFile } from "atomically"
import path from "node:path"
import { fileURLToPath } from "node:url"
import { Project, SourceFile, SyntaxKind } from "ts-morph"

const sourceDirectory = fileURLToPath(new URL("../src", import.meta.url))
const fsDirectory = path.resolve(sourceDirectory, "fs")
const naDirectory = path.resolve(sourceDirectory, "na")

const isDryRun = process.argv.includes("--dry-run")
const targetArgument = process.argv.find((argument) => argument.startsWith("--target="))?.split("=")[1]

const header = `//
// Auto-generated by scripts/generate-barrel.ts
// Do not edit this file directly
//
`

const isRuntimeValueKind = (kind: SyntaxKind): boolean => {
    switch (kind) {
        case SyntaxKind.ClassDeclaration:
        case SyntaxKind.EnumDeclaration:
        case SyntaxKind.FunctionDeclaration:
        case SyntaxKind.ModuleDeclaration:
        case SyntaxKind.VariableDeclaration: {
            return true
        }
        case SyntaxKind.InterfaceDeclaration:
        case SyntaxKind.TypeAliasDeclaration: {
            return false
        }
        default: {
            return true
        }
    }
}

const normalizeRelativePath = (filePath: string): string => {
    const relative = path.relative(sourceDirectory, filePath).replaceAll("\\", "/")
    return `./${relative.replace(/\.ts$/, ".js")}`
}

const analyzeFileExports = (file: SourceFile) => {
    const values: string[] = []
    const types: string[] = []

    for (const symbol of file.getExportSymbols()) {
        const name = symbol.getName()
        if (name === "default") continue

        const declarations = symbol.getDeclarations()
        if (declarations.length === 0) continue

        const decl = declarations[0]

        const kind = decl?.getKind() ?? SyntaxKind.Unknown
        if (isRuntimeValueKind(kind)) values.push(name)
        else types.push(name)
    }

    return { types, values }
}

const generateExportStatements = (file: SourceFile): string => {
    const { types, values } = analyzeFileExports(file)
    if (values.length === 0 && types.length === 0) return ""

    const relativePath = normalizeRelativePath(file.getFilePath())
    let out = ""

    if (values.length > 0) out += `export { ${values.toSorted().join(", ")} } from '${relativePath}';\n`
    if (types.length > 0) {
        out += `export type { ${types.toSorted().join(", ")} } from '${relativePath}';\n`
    }

    return out
}

const generateBarrel = async (targetFilePath: string, fileFilter: (filePath: string) => boolean) => {
    const project = new Project({ tsConfigFilePath: "./tsconfig.json" })

    const sourceFiles = project
        .getSourceFiles("src/**/*.ts")
        .filter((f) => !f.getFilePath().endsWith(".d.ts"))
        // Exclude the barrel files themselves so they don't import each other
        .filter((f) => f.getFilePath() !== path.resolve(sourceDirectory, "index.ts"))
        .filter((f) => f.getFilePath() !== path.resolve(sourceDirectory, "node.ts"))
        .filter((f) => f.getFilePath() !== path.resolve(sourceDirectory, "na.ts"))
        .filter((f) => !f.getBaseName().startsWith("index."))
        .filter((f) => fileFilter(f.getFilePath()))
        .toSorted((a, b) => a.getFilePath().localeCompare(b.getFilePath()))

    let body = ""
    for (const file of sourceFiles) body += generateExportStatements(file)

    const finalContent = `${header + body}\n`

    if (isDryRun) {
        // If targeting specific file (via ESLint), output raw content only.
        if (targetArgument) {
            process.stdout.write(finalContent)
        } else {
            // If running manually, output separators for clarity.
            process.stdout.write(`--- ${path.basename(targetFilePath)} ---\n`)
            process.stdout.write(finalContent)
        }
    } else {
        await writeFile(targetFilePath, finalContent)
        console.log(`Generated barrel: ${path.basename(targetFilePath)} (${sourceFiles.length} files)`)
    }
}

try {
    const mainBarrel = path.resolve(sourceDirectory, "index.ts")
    const naBarrel = path.resolve(sourceDirectory, "na.ts")
    const nodeBarrel = path.resolve(sourceDirectory, "node.ts")

    // 1. Generate Main Barrel (Everything except src/fs)
    if (!targetArgument || targetArgument === "index.ts") {
        await generateBarrel(
            mainBarrel,
            (filePath) => !(filePath.startsWith(fsDirectory) || filePath.startsWith(naDirectory)),
        )
    }

    // 2. Generate Node Barrel (only src/fs)
    if (!targetArgument || targetArgument === "node.ts") {
        await generateBarrel(nodeBarrel, (filePath) => filePath.startsWith(fsDirectory))
    }

    // 2. Generate NA Barrel (only src/na)
    if (!targetArgument || targetArgument === "na.ts") {
        await generateBarrel(naBarrel, (filePath) => filePath.startsWith(naDirectory))
    }
} catch (error: unknown) {
    throw new Error(`Barrel generation failure: ${error as string}`)
}
